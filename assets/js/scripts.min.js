/* ========================================================================
 * Bootstrap: transition.js v3.3.4
 * http://getbootstrap.com/javascript/#transitions
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function($) {
    "use strict";
    // CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)
    // ============================================================
    function transitionEnd() {
        var el = document.createElement("bootstrap");
        var transEndEventNames = {
            WebkitTransition: "webkitTransitionEnd",
            MozTransition: "transitionend",
            OTransition: "oTransitionEnd otransitionend",
            transition: "transitionend"
        };
        for (var name in transEndEventNames) {
            if (el.style[name] !== undefined) {
                return {
                    end: transEndEventNames[name]
                };
            }
        }
        return false;
    }
    // http://blog.alexmaccaw.com/css-transitions
    $.fn.emulateTransitionEnd = function(duration) {
        var called = false;
        var $el = this;
        $(this).one("bsTransitionEnd", function() {
            called = true;
        });
        var callback = function() {
            if (!called) $($el).trigger($.support.transition.end);
        };
        setTimeout(callback, duration);
        return this;
    };
    $(function() {
        $.support.transition = transitionEnd();
        if (!$.support.transition) return;
        $.event.special.bsTransitionEnd = {
            bindType: $.support.transition.end,
            delegateType: $.support.transition.end,
            handle: function(e) {
                if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments);
            }
        };
    });
}(jQuery);

/* ========================================================================
 * Bootstrap: button.js v3.3.4
 * http://getbootstrap.com/javascript/#buttons
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function($) {
    "use strict";
    // BUTTON PUBLIC CLASS DEFINITION
    // ==============================
    var Button = function(element, options) {
        this.$element = $(element);
        this.options = $.extend({}, Button.DEFAULTS, options);
        this.isLoading = false;
    };
    Button.VERSION = "3.3.4";
    Button.DEFAULTS = {
        loadingText: "loading..."
    };
    Button.prototype.setState = function(state) {
        var d = "disabled";
        var $el = this.$element;
        var val = $el.is("input") ? "val" : "html";
        var data = $el.data();
        state = state + "Text";
        if (data.resetText == null) $el.data("resetText", $el[val]());
        // push to event loop to allow forms to submit
        setTimeout($.proxy(function() {
            $el[val](data[state] == null ? this.options[state] : data[state]);
            if (state == "loadingText") {
                this.isLoading = true;
                $el.addClass(d).attr(d, d);
            } else if (this.isLoading) {
                this.isLoading = false;
                $el.removeClass(d).removeAttr(d);
            }
        }, this), 0);
    };
    Button.prototype.toggle = function() {
        var changed = true;
        var $parent = this.$element.closest('[data-toggle="buttons"]');
        if ($parent.length) {
            var $input = this.$element.find("input");
            if ($input.prop("type") == "radio") {
                if ($input.prop("checked") && this.$element.hasClass("active")) changed = false; else $parent.find(".active").removeClass("active");
            }
            if (changed) $input.prop("checked", !this.$element.hasClass("active")).trigger("change");
        } else {
            this.$element.attr("aria-pressed", !this.$element.hasClass("active"));
        }
        if (changed) this.$element.toggleClass("active");
    };
    // BUTTON PLUGIN DEFINITION
    // ========================
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this);
            var data = $this.data("bs.button");
            var options = typeof option == "object" && option;
            if (!data) $this.data("bs.button", data = new Button(this, options));
            if (option == "toggle") data.toggle(); else if (option) data.setState(option);
        });
    }
    var old = $.fn.button;
    $.fn.button = Plugin;
    $.fn.button.Constructor = Button;
    // BUTTON NO CONFLICT
    // ==================
    $.fn.button.noConflict = function() {
        $.fn.button = old;
        return this;
    };
    // BUTTON DATA-API
    // ===============
    $(document).on("click.bs.button.data-api", '[data-toggle^="button"]', function(e) {
        var $btn = $(e.target);
        if (!$btn.hasClass("btn")) $btn = $btn.closest(".btn");
        Plugin.call($btn, "toggle");
        e.preventDefault();
    }).on("focus.bs.button.data-api blur.bs.button.data-api", '[data-toggle^="button"]', function(e) {
        $(e.target).closest(".btn").toggleClass("focus", /^focus(in)?$/.test(e.type));
    });
}(jQuery);

/* ========================================================================
 * Bootstrap: collapse.js v3.3.4
 * http://getbootstrap.com/javascript/#collapse
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function($) {
    "use strict";
    // COLLAPSE PUBLIC CLASS DEFINITION
    // ================================
    var Collapse = function(element, options) {
        this.$element = $(element);
        this.options = $.extend({}, Collapse.DEFAULTS, options);
        this.$trigger = $('[data-toggle="collapse"][href="#' + element.id + '"],' + '[data-toggle="collapse"][data-target="#' + element.id + '"]');
        this.transitioning = null;
        if (this.options.parent) {
            this.$parent = this.getParent();
        } else {
            this.addAriaAndCollapsedClass(this.$element, this.$trigger);
        }
        if (this.options.toggle) this.toggle();
    };
    Collapse.VERSION = "3.3.4";
    Collapse.TRANSITION_DURATION = 350;
    Collapse.DEFAULTS = {
        toggle: true
    };
    Collapse.prototype.dimension = function() {
        var hasWidth = this.$element.hasClass("width");
        return hasWidth ? "width" : "height";
    };
    Collapse.prototype.show = function() {
        if (this.transitioning || this.$element.hasClass("in")) return;
        var activesData;
        var actives = this.$parent && this.$parent.children(".panel").children(".in, .collapsing");
        if (actives && actives.length) {
            activesData = actives.data("bs.collapse");
            if (activesData && activesData.transitioning) return;
        }
        var startEvent = $.Event("show.bs.collapse");
        this.$element.trigger(startEvent);
        if (startEvent.isDefaultPrevented()) return;
        if (actives && actives.length) {
            Plugin.call(actives, "hide");
            activesData || actives.data("bs.collapse", null);
        }
        var dimension = this.dimension();
        this.$element.removeClass("collapse").addClass("collapsing")[dimension](0).attr("aria-expanded", true);
        this.$trigger.removeClass("collapsed").attr("aria-expanded", true);
        this.transitioning = 1;
        var complete = function() {
            this.$element.removeClass("collapsing").addClass("collapse in")[dimension]("");
            this.transitioning = 0;
            this.$element.trigger("shown.bs.collapse");
        };
        if (!$.support.transition) return complete.call(this);
        var scrollSize = $.camelCase([ "scroll", dimension ].join("-"));
        this.$element.one("bsTransitionEnd", $.proxy(complete, this)).emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize]);
    };
    Collapse.prototype.hide = function() {
        if (this.transitioning || !this.$element.hasClass("in")) return;
        var startEvent = $.Event("hide.bs.collapse");
        this.$element.trigger(startEvent);
        if (startEvent.isDefaultPrevented()) return;
        var dimension = this.dimension();
        this.$element[dimension](this.$element[dimension]())[0].offsetHeight;
        this.$element.addClass("collapsing").removeClass("collapse in").attr("aria-expanded", false);
        this.$trigger.addClass("collapsed").attr("aria-expanded", false);
        this.transitioning = 1;
        var complete = function() {
            this.transitioning = 0;
            this.$element.removeClass("collapsing").addClass("collapse").trigger("hidden.bs.collapse");
        };
        if (!$.support.transition) return complete.call(this);
        this.$element[dimension](0).one("bsTransitionEnd", $.proxy(complete, this)).emulateTransitionEnd(Collapse.TRANSITION_DURATION);
    };
    Collapse.prototype.toggle = function() {
        this[this.$element.hasClass("in") ? "hide" : "show"]();
    };
    Collapse.prototype.getParent = function() {
        return $(this.options.parent).find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]').each($.proxy(function(i, element) {
            var $element = $(element);
            this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element);
        }, this)).end();
    };
    Collapse.prototype.addAriaAndCollapsedClass = function($element, $trigger) {
        var isOpen = $element.hasClass("in");
        $element.attr("aria-expanded", isOpen);
        $trigger.toggleClass("collapsed", !isOpen).attr("aria-expanded", isOpen);
    };
    function getTargetFromTrigger($trigger) {
        var href;
        var target = $trigger.attr("data-target") || (href = $trigger.attr("href")) && href.replace(/.*(?=#[^\s]+$)/, "");
        // strip for ie7
        return $(target);
    }
    // COLLAPSE PLUGIN DEFINITION
    // ==========================
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this);
            var data = $this.data("bs.collapse");
            var options = $.extend({}, Collapse.DEFAULTS, $this.data(), typeof option == "object" && option);
            if (!data && options.toggle && /show|hide/.test(option)) options.toggle = false;
            if (!data) $this.data("bs.collapse", data = new Collapse(this, options));
            if (typeof option == "string") data[option]();
        });
    }
    var old = $.fn.collapse;
    $.fn.collapse = Plugin;
    $.fn.collapse.Constructor = Collapse;
    // COLLAPSE NO CONFLICT
    // ====================
    $.fn.collapse.noConflict = function() {
        $.fn.collapse = old;
        return this;
    };
    // COLLAPSE DATA-API
    // =================
    $(document).on("click.bs.collapse.data-api", '[data-toggle="collapse"]', function(e) {
        var $this = $(this);
        if (!$this.attr("data-target")) e.preventDefault();
        var $target = getTargetFromTrigger($this);
        var data = $target.data("bs.collapse");
        var option = data ? "toggle" : $this.data();
        Plugin.call($target, option);
    });
}(jQuery);

/* ========================================================================
 * Bootstrap: dropdown.js v3.3.4
 * http://getbootstrap.com/javascript/#dropdowns
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function($) {
    "use strict";
    // DROPDOWN CLASS DEFINITION
    // =========================
    var backdrop = ".dropdown-backdrop";
    var toggle = '[data-toggle="dropdown"]';
    var Dropdown = function(element) {
        $(element).on("click.bs.dropdown", this.toggle);
    };
    Dropdown.VERSION = "3.3.4";
    Dropdown.prototype.toggle = function(e) {
        var $this = $(this);
        if ($this.is(".disabled, :disabled")) return;
        var $parent = getParent($this);
        var isActive = $parent.hasClass("open");
        clearMenus();
        if (!isActive) {
            if ("ontouchstart" in document.documentElement && !$parent.closest(".navbar-nav").length) {
                // if mobile we use a backdrop because click events don't delegate
                $('<div class="dropdown-backdrop"/>').insertAfter($(this)).on("click", clearMenus);
            }
            var relatedTarget = {
                relatedTarget: this
            };
            $parent.trigger(e = $.Event("show.bs.dropdown", relatedTarget));
            if (e.isDefaultPrevented()) return;
            $this.trigger("focus").attr("aria-expanded", "true");
            $parent.toggleClass("open").trigger("shown.bs.dropdown", relatedTarget);
        }
        return false;
    };
    Dropdown.prototype.keydown = function(e) {
        if (!/(38|40|27|32)/.test(e.which) || /input|textarea/i.test(e.target.tagName)) return;
        var $this = $(this);
        e.preventDefault();
        e.stopPropagation();
        if ($this.is(".disabled, :disabled")) return;
        var $parent = getParent($this);
        var isActive = $parent.hasClass("open");
        if (!isActive && e.which != 27 || isActive && e.which == 27) {
            if (e.which == 27) $parent.find(toggle).trigger("focus");
            return $this.trigger("click");
        }
        var desc = " li:not(.disabled):visible a";
        var $items = $parent.find('[role="menu"]' + desc + ', [role="listbox"]' + desc);
        if (!$items.length) return;
        var index = $items.index(e.target);
        if (e.which == 38 && index > 0) index--;
        // up
        if (e.which == 40 && index < $items.length - 1) index++;
        // down
        if (!~index) index = 0;
        $items.eq(index).trigger("focus");
    };
    function clearMenus(e) {
        if (e && e.which === 3) return;
        $(backdrop).remove();
        $(toggle).each(function() {
            var $this = $(this);
            var $parent = getParent($this);
            var relatedTarget = {
                relatedTarget: this
            };
            if (!$parent.hasClass("open")) return;
            $parent.trigger(e = $.Event("hide.bs.dropdown", relatedTarget));
            if (e.isDefaultPrevented()) return;
            $this.attr("aria-expanded", "false");
            $parent.removeClass("open").trigger("hidden.bs.dropdown", relatedTarget);
        });
    }
    function getParent($this) {
        var selector = $this.attr("data-target");
        if (!selector) {
            selector = $this.attr("href");
            selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, "");
        }
        var $parent = selector && $(selector);
        return $parent && $parent.length ? $parent : $this.parent();
    }
    // DROPDOWN PLUGIN DEFINITION
    // ==========================
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this);
            var data = $this.data("bs.dropdown");
            if (!data) $this.data("bs.dropdown", data = new Dropdown(this));
            if (typeof option == "string") data[option].call($this);
        });
    }
    var old = $.fn.dropdown;
    $.fn.dropdown = Plugin;
    $.fn.dropdown.Constructor = Dropdown;
    // DROPDOWN NO CONFLICT
    // ====================
    $.fn.dropdown.noConflict = function() {
        $.fn.dropdown = old;
        return this;
    };
    // APPLY TO STANDARD DROPDOWN ELEMENTS
    // ===================================
    $(document).on("click.bs.dropdown.data-api", clearMenus).on("click.bs.dropdown.data-api", ".dropdown form", function(e) {
        e.stopPropagation();
    }).on("click.bs.dropdown.data-api", toggle, Dropdown.prototype.toggle).on("keydown.bs.dropdown.data-api", toggle, Dropdown.prototype.keydown).on("keydown.bs.dropdown.data-api", '[role="menu"]', Dropdown.prototype.keydown).on("keydown.bs.dropdown.data-api", '[role="listbox"]', Dropdown.prototype.keydown);
}(jQuery);

/* ========================================================================
 * Bootstrap: tooltip.js v3.3.4
 * http://getbootstrap.com/javascript/#tooltip
 * Inspired by the original jQuery.tipsy by Jason Frame
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function($) {
    "use strict";
    // TOOLTIP PUBLIC CLASS DEFINITION
    // ===============================
    var Tooltip = function(element, options) {
        this.type = null;
        this.options = null;
        this.enabled = null;
        this.timeout = null;
        this.hoverState = null;
        this.$element = null;
        this.init("tooltip", element, options);
    };
    Tooltip.VERSION = "3.3.4";
    Tooltip.TRANSITION_DURATION = 150;
    Tooltip.DEFAULTS = {
        animation: true,
        placement: "top",
        selector: false,
        template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
        trigger: "hover focus",
        title: "",
        delay: 0,
        html: false,
        container: false,
        viewport: {
            selector: "body",
            padding: 0
        }
    };
    Tooltip.prototype.init = function(type, element, options) {
        this.enabled = true;
        this.type = type;
        this.$element = $(element);
        this.options = this.getOptions(options);
        this.$viewport = this.options.viewport && $(this.options.viewport.selector || this.options.viewport);
        if (this.$element[0] instanceof document.constructor && !this.options.selector) {
            throw new Error("`selector` option must be specified when initializing " + this.type + " on the window.document object!");
        }
        var triggers = this.options.trigger.split(" ");
        for (var i = triggers.length; i--; ) {
            var trigger = triggers[i];
            if (trigger == "click") {
                this.$element.on("click." + this.type, this.options.selector, $.proxy(this.toggle, this));
            } else if (trigger != "manual") {
                var eventIn = trigger == "hover" ? "mouseenter" : "focusin";
                var eventOut = trigger == "hover" ? "mouseleave" : "focusout";
                this.$element.on(eventIn + "." + this.type, this.options.selector, $.proxy(this.enter, this));
                this.$element.on(eventOut + "." + this.type, this.options.selector, $.proxy(this.leave, this));
            }
        }
        this.options.selector ? this._options = $.extend({}, this.options, {
            trigger: "manual",
            selector: ""
        }) : this.fixTitle();
    };
    Tooltip.prototype.getDefaults = function() {
        return Tooltip.DEFAULTS;
    };
    Tooltip.prototype.getOptions = function(options) {
        options = $.extend({}, this.getDefaults(), this.$element.data(), options);
        if (options.delay && typeof options.delay == "number") {
            options.delay = {
                show: options.delay,
                hide: options.delay
            };
        }
        return options;
    };
    Tooltip.prototype.getDelegateOptions = function() {
        var options = {};
        var defaults = this.getDefaults();
        this._options && $.each(this._options, function(key, value) {
            if (defaults[key] != value) options[key] = value;
        });
        return options;
    };
    Tooltip.prototype.enter = function(obj) {
        var self = obj instanceof this.constructor ? obj : $(obj.currentTarget).data("bs." + this.type);
        if (self && self.$tip && self.$tip.is(":visible")) {
            self.hoverState = "in";
            return;
        }
        if (!self) {
            self = new this.constructor(obj.currentTarget, this.getDelegateOptions());
            $(obj.currentTarget).data("bs." + this.type, self);
        }
        clearTimeout(self.timeout);
        self.hoverState = "in";
        if (!self.options.delay || !self.options.delay.show) return self.show();
        self.timeout = setTimeout(function() {
            if (self.hoverState == "in") self.show();
        }, self.options.delay.show);
    };
    Tooltip.prototype.leave = function(obj) {
        var self = obj instanceof this.constructor ? obj : $(obj.currentTarget).data("bs." + this.type);
        if (!self) {
            self = new this.constructor(obj.currentTarget, this.getDelegateOptions());
            $(obj.currentTarget).data("bs." + this.type, self);
        }
        clearTimeout(self.timeout);
        self.hoverState = "out";
        if (!self.options.delay || !self.options.delay.hide) return self.hide();
        self.timeout = setTimeout(function() {
            if (self.hoverState == "out") self.hide();
        }, self.options.delay.hide);
    };
    Tooltip.prototype.show = function() {
        var e = $.Event("show.bs." + this.type);
        if (this.hasContent() && this.enabled) {
            this.$element.trigger(e);
            var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0]);
            if (e.isDefaultPrevented() || !inDom) return;
            var that = this;
            var $tip = this.tip();
            var tipId = this.getUID(this.type);
            this.setContent();
            $tip.attr("id", tipId);
            this.$element.attr("aria-describedby", tipId);
            if (this.options.animation) $tip.addClass("fade");
            var placement = typeof this.options.placement == "function" ? this.options.placement.call(this, $tip[0], this.$element[0]) : this.options.placement;
            var autoToken = /\s?auto?\s?/i;
            var autoPlace = autoToken.test(placement);
            if (autoPlace) placement = placement.replace(autoToken, "") || "top";
            $tip.detach().css({
                top: 0,
                left: 0,
                display: "block"
            }).addClass(placement).data("bs." + this.type, this);
            this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element);
            var pos = this.getPosition();
            var actualWidth = $tip[0].offsetWidth;
            var actualHeight = $tip[0].offsetHeight;
            if (autoPlace) {
                var orgPlacement = placement;
                var $container = this.options.container ? $(this.options.container) : this.$element.parent();
                var containerDim = this.getPosition($container);
                placement = placement == "bottom" && pos.bottom + actualHeight > containerDim.bottom ? "top" : placement == "top" && pos.top - actualHeight < containerDim.top ? "bottom" : placement == "right" && pos.right + actualWidth > containerDim.width ? "left" : placement == "left" && pos.left - actualWidth < containerDim.left ? "right" : placement;
                $tip.removeClass(orgPlacement).addClass(placement);
            }
            var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight);
            this.applyPlacement(calculatedOffset, placement);
            var complete = function() {
                var prevHoverState = that.hoverState;
                that.$element.trigger("shown.bs." + that.type);
                that.hoverState = null;
                if (prevHoverState == "out") that.leave(that);
            };
            $.support.transition && this.$tip.hasClass("fade") ? $tip.one("bsTransitionEnd", complete).emulateTransitionEnd(Tooltip.TRANSITION_DURATION) : complete();
        }
    };
    Tooltip.prototype.applyPlacement = function(offset, placement) {
        var $tip = this.tip();
        var width = $tip[0].offsetWidth;
        var height = $tip[0].offsetHeight;
        // manually read margins because getBoundingClientRect includes difference
        var marginTop = parseInt($tip.css("margin-top"), 10);
        var marginLeft = parseInt($tip.css("margin-left"), 10);
        // we must check for NaN for ie 8/9
        if (isNaN(marginTop)) marginTop = 0;
        if (isNaN(marginLeft)) marginLeft = 0;
        offset.top = offset.top + marginTop;
        offset.left = offset.left + marginLeft;
        // $.fn.offset doesn't round pixel values
        // so we use setOffset directly with our own function B-0
        $.offset.setOffset($tip[0], $.extend({
            using: function(props) {
                $tip.css({
                    top: Math.round(props.top),
                    left: Math.round(props.left)
                });
            }
        }, offset), 0);
        $tip.addClass("in");
        // check to see if placing tip in new offset caused the tip to resize itself
        var actualWidth = $tip[0].offsetWidth;
        var actualHeight = $tip[0].offsetHeight;
        if (placement == "top" && actualHeight != height) {
            offset.top = offset.top + height - actualHeight;
        }
        var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight);
        if (delta.left) offset.left += delta.left; else offset.top += delta.top;
        var isVertical = /top|bottom/.test(placement);
        var arrowDelta = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight;
        var arrowOffsetPosition = isVertical ? "offsetWidth" : "offsetHeight";
        $tip.offset(offset);
        this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical);
    };
    Tooltip.prototype.replaceArrow = function(delta, dimension, isVertical) {
        this.arrow().css(isVertical ? "left" : "top", 50 * (1 - delta / dimension) + "%").css(isVertical ? "top" : "left", "");
    };
    Tooltip.prototype.setContent = function() {
        var $tip = this.tip();
        var title = this.getTitle();
        $tip.find(".tooltip-inner")[this.options.html ? "html" : "text"](title);
        $tip.removeClass("fade in top bottom left right");
    };
    Tooltip.prototype.hide = function(callback) {
        var that = this;
        var $tip = $(this.$tip);
        var e = $.Event("hide.bs." + this.type);
        function complete() {
            if (that.hoverState != "in") $tip.detach();
            that.$element.removeAttr("aria-describedby").trigger("hidden.bs." + that.type);
            callback && callback();
        }
        this.$element.trigger(e);
        if (e.isDefaultPrevented()) return;
        $tip.removeClass("in");
        $.support.transition && $tip.hasClass("fade") ? $tip.one("bsTransitionEnd", complete).emulateTransitionEnd(Tooltip.TRANSITION_DURATION) : complete();
        this.hoverState = null;
        return this;
    };
    Tooltip.prototype.fixTitle = function() {
        var $e = this.$element;
        if ($e.attr("title") || typeof $e.attr("data-original-title") != "string") {
            $e.attr("data-original-title", $e.attr("title") || "").attr("title", "");
        }
    };
    Tooltip.prototype.hasContent = function() {
        return this.getTitle();
    };
    Tooltip.prototype.getPosition = function($element) {
        $element = $element || this.$element;
        var el = $element[0];
        var isBody = el.tagName == "BODY";
        var elRect = el.getBoundingClientRect();
        if (elRect.width == null) {
            // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093
            elRect = $.extend({}, elRect, {
                width: elRect.right - elRect.left,
                height: elRect.bottom - elRect.top
            });
        }
        var elOffset = isBody ? {
            top: 0,
            left: 0
        } : $element.offset();
        var scroll = {
            scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop()
        };
        var outerDims = isBody ? {
            width: $(window).width(),
            height: $(window).height()
        } : null;
        return $.extend({}, elRect, scroll, outerDims, elOffset);
    };
    Tooltip.prototype.getCalculatedOffset = function(placement, pos, actualWidth, actualHeight) {
        /* placement == 'right' */
        return placement == "bottom" ? {
            top: pos.top + pos.height,
            left: pos.left + pos.width / 2 - actualWidth / 2
        } : placement == "top" ? {
            top: pos.top - actualHeight,
            left: pos.left + pos.width / 2 - actualWidth / 2
        } : placement == "left" ? {
            top: pos.top + pos.height / 2 - actualHeight / 2,
            left: pos.left - actualWidth
        } : {
            top: pos.top + pos.height / 2 - actualHeight / 2,
            left: pos.left + pos.width
        };
    };
    Tooltip.prototype.getViewportAdjustedDelta = function(placement, pos, actualWidth, actualHeight) {
        var delta = {
            top: 0,
            left: 0
        };
        if (!this.$viewport) return delta;
        var viewportPadding = this.options.viewport && this.options.viewport.padding || 0;
        var viewportDimensions = this.getPosition(this.$viewport);
        if (/right|left/.test(placement)) {
            var topEdgeOffset = pos.top - viewportPadding - viewportDimensions.scroll;
            var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight;
            if (topEdgeOffset < viewportDimensions.top) {
                // top overflow
                delta.top = viewportDimensions.top - topEdgeOffset;
            } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) {
                // bottom overflow
                delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset;
            }
        } else {
            var leftEdgeOffset = pos.left - viewportPadding;
            var rightEdgeOffset = pos.left + viewportPadding + actualWidth;
            if (leftEdgeOffset < viewportDimensions.left) {
                // left overflow
                delta.left = viewportDimensions.left - leftEdgeOffset;
            } else if (rightEdgeOffset > viewportDimensions.width) {
                // right overflow
                delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset;
            }
        }
        return delta;
    };
    Tooltip.prototype.getTitle = function() {
        var title;
        var $e = this.$element;
        var o = this.options;
        title = $e.attr("data-original-title") || (typeof o.title == "function" ? o.title.call($e[0]) : o.title);
        return title;
    };
    Tooltip.prototype.getUID = function(prefix) {
        do prefix += ~~(Math.random() * 1e6); while (document.getElementById(prefix));
        return prefix;
    };
    Tooltip.prototype.tip = function() {
        return this.$tip = this.$tip || $(this.options.template);
    };
    Tooltip.prototype.arrow = function() {
        return this.$arrow = this.$arrow || this.tip().find(".tooltip-arrow");
    };
    Tooltip.prototype.enable = function() {
        this.enabled = true;
    };
    Tooltip.prototype.disable = function() {
        this.enabled = false;
    };
    Tooltip.prototype.toggleEnabled = function() {
        this.enabled = !this.enabled;
    };
    Tooltip.prototype.toggle = function(e) {
        var self = this;
        if (e) {
            self = $(e.currentTarget).data("bs." + this.type);
            if (!self) {
                self = new this.constructor(e.currentTarget, this.getDelegateOptions());
                $(e.currentTarget).data("bs." + this.type, self);
            }
        }
        self.tip().hasClass("in") ? self.leave(self) : self.enter(self);
    };
    Tooltip.prototype.destroy = function() {
        var that = this;
        clearTimeout(this.timeout);
        this.hide(function() {
            that.$element.off("." + that.type).removeData("bs." + that.type);
        });
    };
    // TOOLTIP PLUGIN DEFINITION
    // =========================
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this);
            var data = $this.data("bs.tooltip");
            var options = typeof option == "object" && option;
            if (!data && /destroy|hide/.test(option)) return;
            if (!data) $this.data("bs.tooltip", data = new Tooltip(this, options));
            if (typeof option == "string") data[option]();
        });
    }
    var old = $.fn.tooltip;
    $.fn.tooltip = Plugin;
    $.fn.tooltip.Constructor = Tooltip;
    // TOOLTIP NO CONFLICT
    // ===================
    $.fn.tooltip.noConflict = function() {
        $.fn.tooltip = old;
        return this;
    };
}(jQuery);

/* ========================================================================
 * Bootstrap: popover.js v3.3.4
 * http://getbootstrap.com/javascript/#popovers
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function($) {
    "use strict";
    // POPOVER PUBLIC CLASS DEFINITION
    // ===============================
    var Popover = function(element, options) {
        this.init("popover", element, options);
    };
    if (!$.fn.tooltip) throw new Error("Popover requires tooltip.js");
    Popover.VERSION = "3.3.4";
    Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {
        placement: "right",
        trigger: "click",
        content: "",
        template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
    });
    // NOTE: POPOVER EXTENDS tooltip.js
    // ================================
    Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype);
    Popover.prototype.constructor = Popover;
    Popover.prototype.getDefaults = function() {
        return Popover.DEFAULTS;
    };
    Popover.prototype.setContent = function() {
        var $tip = this.tip();
        var title = this.getTitle();
        var content = this.getContent();
        $tip.find(".popover-title")[this.options.html ? "html" : "text"](title);
        $tip.find(".popover-content").children().detach().end()[// we use append for html objects to maintain js events
        this.options.html ? typeof content == "string" ? "html" : "append" : "text"](content);
        $tip.removeClass("fade top bottom left right in");
        // IE8 doesn't accept hiding via the `:empty` pseudo selector, we have to do
        // this manually by checking the contents.
        if (!$tip.find(".popover-title").html()) $tip.find(".popover-title").hide();
    };
    Popover.prototype.hasContent = function() {
        return this.getTitle() || this.getContent();
    };
    Popover.prototype.getContent = function() {
        var $e = this.$element;
        var o = this.options;
        return $e.attr("data-content") || (typeof o.content == "function" ? o.content.call($e[0]) : o.content);
    };
    Popover.prototype.arrow = function() {
        return this.$arrow = this.$arrow || this.tip().find(".arrow");
    };
    // POPOVER PLUGIN DEFINITION
    // =========================
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this);
            var data = $this.data("bs.popover");
            var options = typeof option == "object" && option;
            if (!data && /destroy|hide/.test(option)) return;
            if (!data) $this.data("bs.popover", data = new Popover(this, options));
            if (typeof option == "string") data[option]();
        });
    }
    var old = $.fn.popover;
    $.fn.popover = Plugin;
    $.fn.popover.Constructor = Popover;
    // POPOVER NO CONFLICT
    // ===================
    $.fn.popover.noConflict = function() {
        $.fn.popover = old;
        return this;
    };
}(jQuery);

/* ========================================================================
 * Bootstrap: tab.js v3.3.4
 * http://getbootstrap.com/javascript/#tabs
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function($) {
    "use strict";
    // TAB CLASS DEFINITION
    // ====================
    var Tab = function(element) {
        this.element = $(element);
    };
    Tab.VERSION = "3.3.4";
    Tab.TRANSITION_DURATION = 150;
    Tab.prototype.show = function() {
        var $this = this.element;
        var $ul = $this.closest("ul:not(.dropdown-menu)");
        var selector = $this.data("target");
        if (!selector) {
            selector = $this.attr("href");
            selector = selector && selector.replace(/.*(?=#[^\s]*$)/, "");
        }
        if ($this.parent("li").hasClass("active")) return;
        var $previous = $ul.find(".active:last a");
        var hideEvent = $.Event("hide.bs.tab", {
            relatedTarget: $this[0]
        });
        var showEvent = $.Event("show.bs.tab", {
            relatedTarget: $previous[0]
        });
        $previous.trigger(hideEvent);
        $this.trigger(showEvent);
        if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) return;
        var $target = $(selector);
        this.activate($this.closest("li"), $ul);
        this.activate($target, $target.parent(), function() {
            $previous.trigger({
                type: "hidden.bs.tab",
                relatedTarget: $this[0]
            });
            $this.trigger({
                type: "shown.bs.tab",
                relatedTarget: $previous[0]
            });
        });
    };
    Tab.prototype.activate = function(element, container, callback) {
        var $active = container.find("> .active");
        var transition = callback && $.support.transition && ($active.length && $active.hasClass("fade") || !!container.find("> .fade").length);
        function next() {
            $active.removeClass("active").find("> .dropdown-menu > .active").removeClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded", false);
            element.addClass("active").find('[data-toggle="tab"]').attr("aria-expanded", true);
            if (transition) {
                element[0].offsetWidth;
                // reflow for transition
                element.addClass("in");
            } else {
                element.removeClass("fade");
            }
            if (element.parent(".dropdown-menu").length) {
                element.closest("li.dropdown").addClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded", true);
            }
            callback && callback();
        }
        $active.length && transition ? $active.one("bsTransitionEnd", next).emulateTransitionEnd(Tab.TRANSITION_DURATION) : next();
        $active.removeClass("in");
    };
    // TAB PLUGIN DEFINITION
    // =====================
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this);
            var data = $this.data("bs.tab");
            if (!data) $this.data("bs.tab", data = new Tab(this));
            if (typeof option == "string") data[option]();
        });
    }
    var old = $.fn.tab;
    $.fn.tab = Plugin;
    $.fn.tab.Constructor = Tab;
    // TAB NO CONFLICT
    // ===============
    $.fn.tab.noConflict = function() {
        $.fn.tab = old;
        return this;
    };
    // TAB DATA-API
    // ============
    var clickHandler = function(e) {
        e.preventDefault();
        Plugin.call($(this), "show");
    };
    $(document).on("click.bs.tab.data-api", '[data-toggle="tab"]', clickHandler).on("click.bs.tab.data-api", '[data-toggle="pill"]', clickHandler);
}(jQuery);

/* ========================================================================
 * Bootstrap: affix.js v3.3.4
 * http://getbootstrap.com/javascript/#affix
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function($) {
    "use strict";
    // AFFIX CLASS DEFINITION
    // ======================
    var Affix = function(element, options) {
        this.options = $.extend({}, Affix.DEFAULTS, options);
        this.$target = $(this.options.target).on("scroll.bs.affix.data-api", $.proxy(this.checkPosition, this)).on("click.bs.affix.data-api", $.proxy(this.checkPositionWithEventLoop, this));
        this.$element = $(element);
        this.affixed = null;
        this.unpin = null;
        this.pinnedOffset = null;
        this.checkPosition();
    };
    Affix.VERSION = "3.3.4";
    Affix.RESET = "affix affix-top affix-bottom";
    Affix.DEFAULTS = {
        offset: 0,
        target: window
    };
    Affix.prototype.getState = function(scrollHeight, height, offsetTop, offsetBottom) {
        var scrollTop = this.$target.scrollTop();
        var position = this.$element.offset();
        var targetHeight = this.$target.height();
        if (offsetTop != null && this.affixed == "top") return scrollTop < offsetTop ? "top" : false;
        if (this.affixed == "bottom") {
            if (offsetTop != null) return scrollTop + this.unpin <= position.top ? false : "bottom";
            return scrollTop + targetHeight <= scrollHeight - offsetBottom ? false : "bottom";
        }
        var initializing = this.affixed == null;
        var colliderTop = initializing ? scrollTop : position.top;
        var colliderHeight = initializing ? targetHeight : height;
        if (offsetTop != null && scrollTop <= offsetTop) return "top";
        if (offsetBottom != null && colliderTop + colliderHeight >= scrollHeight - offsetBottom) return "bottom";
        return false;
    };
    Affix.prototype.getPinnedOffset = function() {
        if (this.pinnedOffset) return this.pinnedOffset;
        this.$element.removeClass(Affix.RESET).addClass("affix");
        var scrollTop = this.$target.scrollTop();
        var position = this.$element.offset();
        return this.pinnedOffset = position.top - scrollTop;
    };
    Affix.prototype.checkPositionWithEventLoop = function() {
        setTimeout($.proxy(this.checkPosition, this), 1);
    };
    Affix.prototype.checkPosition = function() {
        if (!this.$element.is(":visible")) return;
        var height = this.$element.height();
        var offset = this.options.offset;
        var offsetTop = offset.top;
        var offsetBottom = offset.bottom;
        var scrollHeight = $(document.body).height();
        if (typeof offset != "object") offsetBottom = offsetTop = offset;
        if (typeof offsetTop == "function") offsetTop = offset.top(this.$element);
        if (typeof offsetBottom == "function") offsetBottom = offset.bottom(this.$element);
        var affix = this.getState(scrollHeight, height, offsetTop, offsetBottom);
        if (this.affixed != affix) {
            if (this.unpin != null) this.$element.css("top", "");
            var affixType = "affix" + (affix ? "-" + affix : "");
            var e = $.Event(affixType + ".bs.affix");
            this.$element.trigger(e);
            if (e.isDefaultPrevented()) return;
            this.affixed = affix;
            this.unpin = affix == "bottom" ? this.getPinnedOffset() : null;
            this.$element.removeClass(Affix.RESET).addClass(affixType).trigger(affixType.replace("affix", "affixed") + ".bs.affix");
        }
        if (affix == "bottom") {
            this.$element.offset({
                top: scrollHeight - height - offsetBottom
            });
        }
    };
    // AFFIX PLUGIN DEFINITION
    // =======================
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this);
            var data = $this.data("bs.affix");
            var options = typeof option == "object" && option;
            if (!data) $this.data("bs.affix", data = new Affix(this, options));
            if (typeof option == "string") data[option]();
        });
    }
    var old = $.fn.affix;
    $.fn.affix = Plugin;
    $.fn.affix.Constructor = Affix;
    // AFFIX NO CONFLICT
    // =================
    $.fn.affix.noConflict = function() {
        $.fn.affix = old;
        return this;
    };
    // AFFIX DATA-API
    // ==============
    $(window).on("load", function() {
        $('[data-spy="affix"]').each(function() {
            var $spy = $(this);
            var data = $spy.data();
            data.offset = data.offset || {};
            if (data.offsetBottom != null) data.offset.bottom = data.offsetBottom;
            if (data.offsetTop != null) data.offset.top = data.offsetTop;
            Plugin.call($spy, data);
        });
    });
}(jQuery);

/*!
 * SmartMenus jQuery Plugin - v0.9.7 - August 25, 2014
 * http://www.smartmenus.org/
 *
 * Copyright 2014 Vasil Dinkov, Vadikom Web Ltd.
 * http://vadikom.com
 *
 * Licensed MIT
 */
(function($) {
    var menuTrees = [], IE = !!window.createPopup, // detect it for the iframe shim
    mouse = false, // optimize for touch by default - we will detect for mouse input
    mouseDetectionEnabled = false;
    // Handle detection for mouse input (i.e. desktop browsers, tablets with a mouse, etc.)
    function initMouseDetection(disable) {
        var eNS = ".smartmenus_mouse";
        if (!mouseDetectionEnabled && !disable) {
            // if we get two consecutive mousemoves within 2 pixels from each other and within 300ms, we assume a real mouse/cursor is present
            // in practice, this seems like impossible to trick unintentianally with a real mouse and a pretty safe detection on touch devices (even with older browsers that do not support touch events)
            var firstTime = true, lastMove = null;
            $(document).bind(getEventsNS([ [ "mousemove", function(e) {
                var thisMove = {
                    x: e.pageX,
                    y: e.pageY,
                    timeStamp: new Date().getTime()
                };
                if (lastMove) {
                    var deltaX = Math.abs(lastMove.x - thisMove.x), deltaY = Math.abs(lastMove.y - thisMove.y);
                    if ((deltaX > 0 || deltaY > 0) && deltaX <= 2 && deltaY <= 2 && thisMove.timeStamp - lastMove.timeStamp <= 300) {
                        mouse = true;
                        // if this is the first check after page load, check if we are not over some item by chance and call the mouseenter handler if yes
                        if (firstTime) {
                            var $a = $(e.target).closest("a");
                            if ($a.is("a")) {
                                $.each(menuTrees, function() {
                                    if ($.contains(this.$root[0], $a[0])) {
                                        this.itemEnter({
                                            currentTarget: $a[0]
                                        });
                                        return false;
                                    }
                                });
                            }
                            firstTime = false;
                        }
                    }
                }
                lastMove = thisMove;
            } ], [ touchEvents() ? "touchstart" : "pointerover pointermove pointerout MSPointerOver MSPointerMove MSPointerOut", function(e) {
                if (isTouchEvent(e.originalEvent)) {
                    mouse = false;
                }
            } ] ], eNS));
            mouseDetectionEnabled = true;
        } else if (mouseDetectionEnabled && disable) {
            $(document).unbind(eNS);
            mouseDetectionEnabled = false;
        }
    }
    function isTouchEvent(e) {
        return !/^(4|mouse)$/.test(e.pointerType);
    }
    // we use this just to choose between toucn and pointer events when we need to, not for touch screen detection
    function touchEvents() {
        return "ontouchstart" in window;
    }
    // returns a jQuery bind() ready object
    function getEventsNS(defArr, eNS) {
        if (!eNS) {
            eNS = "";
        }
        var obj = {};
        $.each(defArr, function(index, value) {
            obj[value[0].split(" ").join(eNS + " ") + eNS] = value[1];
        });
        return obj;
    }
    $.SmartMenus = function(elm, options) {
        this.$root = $(elm);
        this.opts = options;
        this.rootId = "";
        // internal
        this.$subArrow = null;
        this.subMenus = [];
        // all sub menus in the tree (UL elms) in no particular order (only real - e.g. UL's in mega sub menus won't be counted)
        this.activatedItems = [];
        // stores last activated A's for each level
        this.visibleSubMenus = [];
        // stores visible sub menus UL's
        this.showTimeout = 0;
        this.hideTimeout = 0;
        this.scrollTimeout = 0;
        this.clickActivated = false;
        this.zIndexInc = 0;
        this.$firstLink = null;
        // we'll use these for some tests
        this.$firstSub = null;
        // at runtime so we'll cache them
        this.disabled = false;
        this.$disableOverlay = null;
        this.isTouchScrolling = false;
        this.init();
    };
    $.extend($.SmartMenus, {
        hideAll: function() {
            $.each(menuTrees, function() {
                this.menuHideAll();
            });
        },
        destroy: function() {
            while (menuTrees.length) {
                menuTrees[0].destroy();
            }
            initMouseDetection(true);
        },
        prototype: {
            init: function(refresh) {
                var self = this;
                if (!refresh) {
                    menuTrees.push(this);
                    this.rootId = (new Date().getTime() + Math.random() + "").replace(/\D/g, "");
                    if (this.$root.hasClass("sm-rtl")) {
                        this.opts.rightToLeftSubMenus = true;
                    }
                    // init root (main menu)
                    var eNS = ".smartmenus";
                    this.$root.data("smartmenus", this).attr("data-smartmenus-id", this.rootId).dataSM("level", 1).bind(getEventsNS([ [ "mouseover focusin", $.proxy(this.rootOver, this) ], [ "mouseout focusout", $.proxy(this.rootOut, this) ] ], eNS)).delegate("a", getEventsNS([ [ "mouseenter", $.proxy(this.itemEnter, this) ], [ "mouseleave", $.proxy(this.itemLeave, this) ], [ "mousedown", $.proxy(this.itemDown, this) ], [ "focus", $.proxy(this.itemFocus, this) ], [ "blur", $.proxy(this.itemBlur, this) ], [ "click", $.proxy(this.itemClick, this) ], [ "touchend", $.proxy(this.itemTouchEnd, this) ] ], eNS));
                    // hide menus on tap or click outside the root UL
                    eNS += this.rootId;
                    if (this.opts.hideOnClick) {
                        $(document).bind(getEventsNS([ [ "touchstart", $.proxy(this.docTouchStart, this) ], [ "touchmove", $.proxy(this.docTouchMove, this) ], [ "touchend", $.proxy(this.docTouchEnd, this) ], // for Opera Mobile < 11.5, webOS browser, etc. we'll check click too
                        [ "click", $.proxy(this.docClick, this) ] ], eNS));
                    }
                    // hide sub menus on resize
                    $(window).bind(getEventsNS([ [ "resize orientationchange", $.proxy(this.winResize, this) ] ], eNS));
                    if (this.opts.subIndicators) {
                        this.$subArrow = $("<span/>").addClass("sub-arrow");
                        if (this.opts.subIndicatorsText) {
                            this.$subArrow.html(this.opts.subIndicatorsText);
                        }
                    }
                    // make sure mouse detection is enabled
                    initMouseDetection();
                }
                // init sub menus
                this.$firstSub = this.$root.find("ul").each(function() {
                    self.menuInit($(this));
                }).eq(0);
                this.$firstLink = this.$root.find("a").eq(0);
                // find current item
                if (this.opts.markCurrentItem) {
                    var reDefaultDoc = /(index|default)\.[^#\?\/]*/i, reHash = /#.*/, locHref = window.location.href.replace(reDefaultDoc, ""), locHrefNoHash = locHref.replace(reHash, "");
                    this.$root.find("a").each(function() {
                        var href = this.href.replace(reDefaultDoc, ""), $this = $(this);
                        if (href == locHref || href == locHrefNoHash) {
                            $this.addClass("current");
                            if (self.opts.markCurrentTree) {
                                $this.parent().parentsUntil("[data-smartmenus-id]", "li").children("a").addClass("current");
                            }
                        }
                    });
                }
            },
            destroy: function() {
                this.menuHideAll();
                var eNS = ".smartmenus";
                this.$root.removeData("smartmenus").removeAttr("data-smartmenus-id").removeDataSM("level").unbind(eNS).undelegate(eNS);
                eNS += this.rootId;
                $(document).unbind(eNS);
                $(window).unbind(eNS);
                if (this.opts.subIndicators) {
                    this.$subArrow = null;
                }
                var self = this;
                $.each(this.subMenus, function() {
                    if (this.hasClass("mega-menu")) {
                        this.find("ul").removeDataSM("in-mega");
                    }
                    if (this.dataSM("shown-before")) {
                        if (self.opts.subMenusMinWidth || self.opts.subMenusMaxWidth) {
                            this.css({
                                width: "",
                                minWidth: "",
                                maxWidth: ""
                            }).removeClass("sm-nowrap");
                        }
                        if (this.dataSM("scroll-arrows")) {
                            this.dataSM("scroll-arrows").remove();
                        }
                        this.css({
                            zIndex: "",
                            top: "",
                            left: "",
                            marginLeft: "",
                            marginTop: "",
                            display: ""
                        });
                    }
                    if (self.opts.subIndicators) {
                        this.dataSM("parent-a").removeClass("has-submenu").children("span.sub-arrow").remove();
                    }
                    this.removeDataSM("shown-before").removeDataSM("ie-shim").removeDataSM("scroll-arrows").removeDataSM("parent-a").removeDataSM("level").removeDataSM("beforefirstshowfired").parent().removeDataSM("sub");
                });
                if (this.opts.markCurrentItem) {
                    this.$root.find("a.current").removeClass("current");
                }
                this.$root = null;
                this.$firstLink = null;
                this.$firstSub = null;
                if (this.$disableOverlay) {
                    this.$disableOverlay.remove();
                    this.$disableOverlay = null;
                }
                menuTrees.splice($.inArray(this, menuTrees), 1);
            },
            disable: function(noOverlay) {
                if (!this.disabled) {
                    this.menuHideAll();
                    // display overlay over the menu to prevent interaction
                    if (!noOverlay && !this.opts.isPopup && this.$root.is(":visible")) {
                        var pos = this.$root.offset();
                        this.$disableOverlay = $('<div class="sm-jquery-disable-overlay"/>').css({
                            position: "absolute",
                            top: pos.top,
                            left: pos.left,
                            width: this.$root.outerWidth(),
                            height: this.$root.outerHeight(),
                            zIndex: this.getStartZIndex(true),
                            opacity: 0
                        }).appendTo(document.body);
                    }
                    this.disabled = true;
                }
            },
            docClick: function(e) {
                if (this.isTouchScrolling) {
                    this.isTouchScrolling = false;
                    return;
                }
                // hide on any click outside the menu or on a menu link
                if (this.visibleSubMenus.length && !$.contains(this.$root[0], e.target) || $(e.target).is("a")) {
                    this.menuHideAll();
                }
            },
            docTouchEnd: function(e) {
                if (!this.lastTouch) {
                    return;
                }
                if (this.visibleSubMenus.length && (this.lastTouch.x2 === undefined || this.lastTouch.x1 == this.lastTouch.x2) && (this.lastTouch.y2 === undefined || this.lastTouch.y1 == this.lastTouch.y2) && (!this.lastTouch.target || !$.contains(this.$root[0], this.lastTouch.target))) {
                    if (this.hideTimeout) {
                        clearTimeout(this.hideTimeout);
                        this.hideTimeout = 0;
                    }
                    // hide with a delay to prevent triggering accidental unwanted click on some page element
                    var self = this;
                    this.hideTimeout = setTimeout(function() {
                        self.menuHideAll();
                    }, 350);
                }
                this.lastTouch = null;
            },
            docTouchMove: function(e) {
                if (!this.lastTouch) {
                    return;
                }
                var touchPoint = e.originalEvent.touches[0];
                this.lastTouch.x2 = touchPoint.pageX;
                this.lastTouch.y2 = touchPoint.pageY;
            },
            docTouchStart: function(e) {
                var touchPoint = e.originalEvent.touches[0];
                this.lastTouch = {
                    x1: touchPoint.pageX,
                    y1: touchPoint.pageY,
                    target: touchPoint.target
                };
            },
            enable: function() {
                if (this.disabled) {
                    if (this.$disableOverlay) {
                        this.$disableOverlay.remove();
                        this.$disableOverlay = null;
                    }
                    this.disabled = false;
                }
            },
            getClosestMenu: function(elm) {
                var $closestMenu = $(elm).closest("ul");
                while ($closestMenu.dataSM("in-mega")) {
                    $closestMenu = $closestMenu.parent().closest("ul");
                }
                return $closestMenu[0] || null;
            },
            getHeight: function($elm) {
                return this.getOffset($elm, true);
            },
            // returns precise width/height float values
            getOffset: function($elm, height) {
                var old;
                if ($elm.css("display") == "none") {
                    old = {
                        position: $elm[0].style.position,
                        visibility: $elm[0].style.visibility
                    };
                    $elm.css({
                        position: "absolute",
                        visibility: "hidden"
                    }).show();
                }
                var box = $elm[0].getBoundingClientRect && $elm[0].getBoundingClientRect(), val = box && (height ? box.height || box.bottom - box.top : box.width || box.right - box.left);
                if (!val && val !== 0) {
                    val = height ? $elm[0].offsetHeight : $elm[0].offsetWidth;
                }
                if (old) {
                    $elm.hide().css(old);
                }
                return val;
            },
            getStartZIndex: function(root) {
                var zIndex = parseInt(this[root ? "$root" : "$firstSub"].css("z-index"));
                if (!root && isNaN(zIndex)) {
                    zIndex = parseInt(this.$root.css("z-index"));
                }
                return !isNaN(zIndex) ? zIndex : 1;
            },
            getTouchPoint: function(e) {
                return e.touches && e.touches[0] || e.changedTouches && e.changedTouches[0] || e;
            },
            getViewport: function(height) {
                var name = height ? "Height" : "Width", val = document.documentElement["client" + name], val2 = window["inner" + name];
                if (val2) {
                    val = Math.min(val, val2);
                }
                return val;
            },
            getViewportHeight: function() {
                return this.getViewport(true);
            },
            getViewportWidth: function() {
                return this.getViewport();
            },
            getWidth: function($elm) {
                return this.getOffset($elm);
            },
            handleEvents: function() {
                return !this.disabled && this.isCSSOn();
            },
            handleItemEvents: function($a) {
                return this.handleEvents() && !this.isLinkInMegaMenu($a);
            },
            isCollapsible: function() {
                return this.$firstSub.css("position") == "static";
            },
            isCSSOn: function() {
                return this.$firstLink.css("display") == "block";
            },
            isFixed: function() {
                var isFixed = this.$root.css("position") == "fixed";
                if (!isFixed) {
                    this.$root.parentsUntil("body").each(function() {
                        if ($(this).css("position") == "fixed") {
                            isFixed = true;
                            return false;
                        }
                    });
                }
                return isFixed;
            },
            isLinkInMegaMenu: function($a) {
                return !$a.parent().parent().dataSM("level");
            },
            isTouchMode: function() {
                return !mouse || this.isCollapsible();
            },
            itemActivate: function($a) {
                var $li = $a.parent(), $ul = $li.parent(), level = $ul.dataSM("level");
                // if for some reason the parent item is not activated (e.g. this is an API call to activate the item), activate all parent items first
                if (level > 1 && (!this.activatedItems[level - 2] || this.activatedItems[level - 2][0] != $ul.dataSM("parent-a")[0])) {
                    var self = this;
                    $($ul.parentsUntil("[data-smartmenus-id]", "ul").get().reverse()).add($ul).each(function() {
                        self.itemActivate($(this).dataSM("parent-a"));
                    });
                }
                // hide any visible deeper level sub menus
                if (this.visibleSubMenus.length > level) {
                    this.menuHideSubMenus(!this.activatedItems[level - 1] || this.activatedItems[level - 1][0] != $a[0] ? level - 1 : level);
                }
                // save new active item and sub menu for this level
                this.activatedItems[level - 1] = $a;
                this.visibleSubMenus[level - 1] = $ul;
                if (this.$root.triggerHandler("activate.smapi", $a[0]) === false) {
                    return;
                }
                // show the sub menu if this item has one
                var $sub = $li.dataSM("sub");
                if ($sub && (this.isTouchMode() || (!this.opts.showOnClick || this.clickActivated))) {
                    this.menuShow($sub);
                }
            },
            itemBlur: function(e) {
                var $a = $(e.currentTarget);
                if (!this.handleItemEvents($a)) {
                    return;
                }
                this.$root.triggerHandler("blur.smapi", $a[0]);
            },
            itemClick: function(e) {
                if (this.isTouchScrolling) {
                    this.isTouchScrolling = false;
                    e.stopPropagation();
                    return false;
                }
                var $a = $(e.currentTarget);
                if (!this.handleItemEvents($a)) {
                    return;
                }
                $a.removeDataSM("mousedown");
                if (this.$root.triggerHandler("click.smapi", $a[0]) === false) {
                    return false;
                }
                var $sub = $a.parent().dataSM("sub");
                if (this.isTouchMode()) {
                    // undo fix: prevent the address bar on iPhone from sliding down when expanding a sub menu
                    if ($a.dataSM("href")) {
                        $a.attr("href", $a.dataSM("href")).removeDataSM("href");
                    }
                    // if the sub is not visible
                    if ($sub && (!$sub.dataSM("shown-before") || !$sub.is(":visible"))) {
                        // try to activate the item and show the sub
                        this.itemActivate($a);
                        // if "itemActivate" showed the sub, prevent the click so that the link is not loaded
                        // if it couldn't show it, then the sub menus are disabled with an !important declaration (e.g. via mobile styles) so let the link get loaded
                        if ($sub.is(":visible")) {
                            return false;
                        }
                    }
                } else if (this.opts.showOnClick && $a.parent().parent().dataSM("level") == 1 && $sub) {
                    this.clickActivated = true;
                    this.menuShow($sub);
                    return false;
                }
                if ($a.hasClass("disabled")) {
                    return false;
                }
                if (this.$root.triggerHandler("select.smapi", $a[0]) === false) {
                    return false;
                }
            },
            itemDown: function(e) {
                var $a = $(e.currentTarget);
                if (!this.handleItemEvents($a)) {
                    return;
                }
                $a.dataSM("mousedown", true);
            },
            itemEnter: function(e) {
                var $a = $(e.currentTarget);
                if (!this.handleItemEvents($a)) {
                    return;
                }
                if (!this.isTouchMode()) {
                    if (this.showTimeout) {
                        clearTimeout(this.showTimeout);
                        this.showTimeout = 0;
                    }
                    var self = this;
                    this.showTimeout = setTimeout(function() {
                        self.itemActivate($a);
                    }, this.opts.showOnClick && $a.parent().parent().dataSM("level") == 1 ? 1 : this.opts.showTimeout);
                }
                this.$root.triggerHandler("mouseenter.smapi", $a[0]);
            },
            itemFocus: function(e) {
                var $a = $(e.currentTarget);
                if (!this.handleItemEvents($a)) {
                    return;
                }
                // fix (the mousedown check): in some browsers a tap/click produces consecutive focus + click events so we don't need to activate the item on focus
                if ((!this.isTouchMode() || !$a.dataSM("mousedown")) && (!this.activatedItems.length || this.activatedItems[this.activatedItems.length - 1][0] != $a[0])) {
                    this.itemActivate($a);
                }
                this.$root.triggerHandler("focus.smapi", $a[0]);
            },
            itemLeave: function(e) {
                var $a = $(e.currentTarget);
                if (!this.handleItemEvents($a)) {
                    return;
                }
                if (!this.isTouchMode()) {
                    if ($a[0].blur) {
                        $a[0].blur();
                    }
                    if (this.showTimeout) {
                        clearTimeout(this.showTimeout);
                        this.showTimeout = 0;
                    }
                }
                $a.removeDataSM("mousedown");
                this.$root.triggerHandler("mouseleave.smapi", $a[0]);
            },
            itemTouchEnd: function(e) {
                var $a = $(e.currentTarget);
                if (!this.handleItemEvents($a)) {
                    return;
                }
                // prevent the address bar on iPhone from sliding down when expanding a sub menu
                var $sub = $a.parent().dataSM("sub");
                if ($a.attr("href").charAt(0) !== "#" && $sub && (!$sub.dataSM("shown-before") || !$sub.is(":visible"))) {
                    $a.dataSM("href", $a.attr("href"));
                    $a.attr("href", "#");
                }
            },
            menuFixLayout: function($ul) {
                // fixes a menu that is being shown for the first time
                if (!$ul.dataSM("shown-before")) {
                    $ul.hide().dataSM("shown-before", true);
                }
            },
            menuHide: function($sub) {
                if (this.$root.triggerHandler("beforehide.smapi", $sub[0]) === false) {
                    return;
                }
                $sub.stop(true, true);
                if ($sub.is(":visible")) {
                    var complete = function() {
                        // unset z-index
                        $sub.css("z-index", "");
                    };
                    // if sub is collapsible (mobile view)
                    if (this.isCollapsible()) {
                        if (this.opts.collapsibleHideFunction) {
                            this.opts.collapsibleHideFunction.call(this, $sub, complete);
                        } else {
                            $sub.hide(this.opts.collapsibleHideDuration, complete);
                        }
                    } else {
                        if (this.opts.hideFunction) {
                            this.opts.hideFunction.call(this, $sub, complete);
                        } else {
                            $sub.hide(this.opts.hideDuration, complete);
                        }
                    }
                    // remove IE iframe shim
                    if ($sub.dataSM("ie-shim")) {
                        $sub.dataSM("ie-shim").remove();
                    }
                    // deactivate scrolling if it is activated for this sub
                    if ($sub.dataSM("scroll")) {
                        this.menuScrollStop($sub);
                        $sub.css({
                            "touch-action": "",
                            "-ms-touch-action": ""
                        }).unbind(".smartmenus_scroll").removeDataSM("scroll").dataSM("scroll-arrows").hide();
                    }
                    // unhighlight parent item
                    $sub.dataSM("parent-a").removeClass("highlighted");
                    var level = $sub.dataSM("level");
                    this.activatedItems.splice(level - 1, 1);
                    this.visibleSubMenus.splice(level - 1, 1);
                    this.$root.triggerHandler("hide.smapi", $sub[0]);
                }
            },
            menuHideAll: function() {
                if (this.showTimeout) {
                    clearTimeout(this.showTimeout);
                    this.showTimeout = 0;
                }
                // hide all subs
                this.menuHideSubMenus();
                // hide root if it's popup
                if (this.opts.isPopup) {
                    this.$root.stop(true, true);
                    if (this.$root.is(":visible")) {
                        if (this.opts.hideFunction) {
                            this.opts.hideFunction.call(this, this.$root);
                        } else {
                            this.$root.hide(this.opts.hideDuration);
                        }
                        // remove IE iframe shim
                        if (this.$root.dataSM("ie-shim")) {
                            this.$root.dataSM("ie-shim").remove();
                        }
                    }
                }
                this.activatedItems = [];
                this.visibleSubMenus = [];
                this.clickActivated = false;
                // reset z-index increment
                this.zIndexInc = 0;
            },
            menuHideSubMenus: function(level) {
                if (!level) level = 0;
                for (var i = this.visibleSubMenus.length - 1; i > level; i--) {
                    this.menuHide(this.visibleSubMenus[i]);
                }
            },
            menuIframeShim: function($ul) {
                // create iframe shim for the menu
                if (IE && this.opts.overlapControlsInIE && !$ul.dataSM("ie-shim")) {
                    $ul.dataSM("ie-shim", $("<iframe/>").attr({
                        src: "javascript:0",
                        tabindex: -9
                    }).css({
                        position: "absolute",
                        top: "auto",
                        left: "0",
                        opacity: 0,
                        border: "0"
                    }));
                }
            },
            menuInit: function($ul) {
                if (!$ul.dataSM("in-mega")) {
                    this.subMenus.push($ul);
                    // mark UL's in mega drop downs (if any) so we can neglect them
                    if ($ul.hasClass("mega-menu")) {
                        $ul.find("ul").dataSM("in-mega", true);
                    }
                    // get level (much faster than, for example, using parentsUntil)
                    var level = 2, par = $ul[0];
                    while ((par = par.parentNode.parentNode) != this.$root[0]) {
                        level++;
                    }
                    // cache stuff
                    $ul.dataSM("parent-a", $ul.prevAll("a").eq(-1)).dataSM("level", level).parent().dataSM("sub", $ul);
                    // add sub indicator to parent item
                    if (this.opts.subIndicators) {
                        $ul.dataSM("parent-a").addClass("has-submenu")[this.opts.subIndicatorsPos](this.$subArrow.clone());
                    }
                }
            },
            menuPosition: function($sub) {
                var $a = $sub.dataSM("parent-a"), $ul = $sub.parent().parent(), level = $sub.dataSM("level"), subW = this.getWidth($sub), subH = this.getHeight($sub), itemOffset = $a.offset(), itemX = itemOffset.left, itemY = itemOffset.top, itemW = this.getWidth($a), itemH = this.getHeight($a), $win = $(window), winX = $win.scrollLeft(), winY = $win.scrollTop(), winW = this.getViewportWidth(), winH = this.getViewportHeight(), horizontalParent = $ul.hasClass("sm") && !$ul.hasClass("sm-vertical"), subOffsetX = level == 2 ? this.opts.mainMenuSubOffsetX : this.opts.subMenusSubOffsetX, subOffsetY = level == 2 ? this.opts.mainMenuSubOffsetY : this.opts.subMenusSubOffsetY, x, y;
                if (horizontalParent) {
                    x = this.opts.rightToLeftSubMenus ? itemW - subW - subOffsetX : subOffsetX;
                    y = this.opts.bottomToTopSubMenus ? -subH - subOffsetY : itemH + subOffsetY;
                } else {
                    x = this.opts.rightToLeftSubMenus ? subOffsetX - subW : itemW - subOffsetX;
                    y = this.opts.bottomToTopSubMenus ? itemH - subOffsetY - subH : subOffsetY;
                }
                if (this.opts.keepInViewport && !this.isCollapsible()) {
                    var absX = itemX + x, absY = itemY + y;
                    if (this.opts.rightToLeftSubMenus && absX < winX) {
                        x = horizontalParent ? winX - absX + x : itemW - subOffsetX;
                    } else if (!this.opts.rightToLeftSubMenus && absX + subW > winX + winW) {
                        x = horizontalParent ? winX + winW - subW - absX + x : subOffsetX - subW;
                    }
                    if (!horizontalParent) {
                        if (subH < winH && absY + subH > winY + winH) {
                            y += winY + winH - subH - absY;
                        } else if (subH >= winH || absY < winY) {
                            y += winY - absY;
                        }
                    }
                    // do we need scrolling?
                    // 0.49 used for better precision when dealing with float values
                    if (horizontalParent && (absY + subH > winY + winH + .49 || absY < winY) || !horizontalParent && subH > winH + .49) {
                        var self = this;
                        if (!$sub.dataSM("scroll-arrows")) {
                            $sub.dataSM("scroll-arrows", $([ $('<span class="scroll-up"><span class="scroll-up-arrow"></span></span>')[0], $('<span class="scroll-down"><span class="scroll-down-arrow"></span></span>')[0] ]).bind({
                                mouseenter: function() {
                                    $sub.dataSM("scroll").up = $(this).hasClass("scroll-up");
                                    self.menuScroll($sub);
                                },
                                mouseleave: function(e) {
                                    self.menuScrollStop($sub);
                                    self.menuScrollOut($sub, e);
                                },
                                "mousewheel DOMMouseScroll": function(e) {
                                    e.preventDefault();
                                }
                            }).insertAfter($sub));
                        }
                        // bind scroll events and save scroll data for this sub
                        var eNS = ".smartmenus_scroll";
                        $sub.dataSM("scroll", {
                            step: 1,
                            // cache stuff for faster recalcs later
                            itemH: itemH,
                            subH: subH,
                            arrowDownH: this.getHeight($sub.dataSM("scroll-arrows").eq(1))
                        }).bind(getEventsNS([ [ "mouseover", function(e) {
                            self.menuScrollOver($sub, e);
                        } ], [ "mouseout", function(e) {
                            self.menuScrollOut($sub, e);
                        } ], [ "mousewheel DOMMouseScroll", function(e) {
                            self.menuScrollMousewheel($sub, e);
                        } ] ], eNS)).dataSM("scroll-arrows").css({
                            top: "auto",
                            left: "0",
                            marginLeft: x + (parseInt($sub.css("border-left-width")) || 0),
                            width: subW - (parseInt($sub.css("border-left-width")) || 0) - (parseInt($sub.css("border-right-width")) || 0),
                            zIndex: $sub.css("z-index")
                        }).eq(horizontalParent && this.opts.bottomToTopSubMenus ? 0 : 1).show();
                        // when a menu tree is fixed positioned we allow scrolling via touch too
                        // since there is no other way to access such long sub menus if no mouse is present
                        if (this.isFixed()) {
                            $sub.css({
                                "touch-action": "none",
                                "-ms-touch-action": "none"
                            }).bind(getEventsNS([ [ touchEvents() ? "touchstart touchmove touchend" : "pointerdown pointermove pointerup MSPointerDown MSPointerMove MSPointerUp", function(e) {
                                self.menuScrollTouch($sub, e);
                            } ] ], eNS));
                        }
                    }
                }
                $sub.css({
                    top: "auto",
                    left: "0",
                    marginLeft: x,
                    marginTop: y - itemH
                });
                // IE iframe shim
                this.menuIframeShim($sub);
                if ($sub.dataSM("ie-shim")) {
                    $sub.dataSM("ie-shim").css({
                        zIndex: $sub.css("z-index"),
                        width: subW,
                        height: subH,
                        marginLeft: x,
                        marginTop: y - itemH
                    });
                }
            },
            menuScroll: function($sub, once, step) {
                var data = $sub.dataSM("scroll"), $arrows = $sub.dataSM("scroll-arrows"), y = parseFloat($sub.css("margin-top")), end = data.up ? data.upEnd : data.downEnd, diff;
                if (!once && data.velocity) {
                    data.velocity *= .9;
                    diff = data.velocity;
                    if (diff < .5) {
                        this.menuScrollStop($sub);
                        return;
                    }
                } else {
                    diff = step || (once || !this.opts.scrollAccelerate ? this.opts.scrollStep : Math.floor(data.step));
                }
                // hide any visible deeper level sub menus
                var level = $sub.dataSM("level");
                if (this.visibleSubMenus.length > level) {
                    this.menuHideSubMenus(level - 1);
                }
                var newY = data.up && end <= y || !data.up && end >= y ? y : Math.abs(end - y) > diff ? y + (data.up ? diff : -diff) : end;
                $sub.add($sub.dataSM("ie-shim")).css("margin-top", newY);
                // show opposite arrow if appropriate
                if (mouse && (data.up && newY > data.downEnd || !data.up && newY < data.upEnd)) {
                    $arrows.eq(data.up ? 1 : 0).show();
                }
                // if we've reached the end
                if (newY == end) {
                    if (mouse) {
                        $arrows.eq(data.up ? 0 : 1).hide();
                    }
                    this.menuScrollStop($sub);
                } else if (!once) {
                    if (this.opts.scrollAccelerate && data.step < this.opts.scrollStep) {
                        data.step += .5;
                    }
                    var self = this;
                    this.scrollTimeout = setTimeout(function() {
                        self.menuScroll($sub);
                    }, this.opts.scrollInterval);
                }
            },
            menuScrollMousewheel: function($sub, e) {
                if (this.getClosestMenu(e.target) == $sub[0]) {
                    e = e.originalEvent;
                    var up = (e.wheelDelta || -e.detail) > 0;
                    if ($sub.dataSM("scroll-arrows").eq(up ? 0 : 1).is(":visible")) {
                        $sub.dataSM("scroll").up = up;
                        this.menuScroll($sub, true);
                    }
                }
                e.preventDefault();
            },
            menuScrollOut: function($sub, e) {
                if (mouse) {
                    if (!/^scroll-(up|down)/.test((e.relatedTarget || "").className) && ($sub[0] != e.relatedTarget && !$.contains($sub[0], e.relatedTarget) || this.getClosestMenu(e.relatedTarget) != $sub[0])) {
                        $sub.dataSM("scroll-arrows").css("visibility", "hidden");
                    }
                }
            },
            menuScrollOver: function($sub, e) {
                if (mouse) {
                    if (!/^scroll-(up|down)/.test(e.target.className) && this.getClosestMenu(e.target) == $sub[0]) {
                        this.menuScrollRefreshData($sub);
                        var data = $sub.dataSM("scroll");
                        $sub.dataSM("scroll-arrows").eq(0).css("margin-top", data.upEnd).end().eq(1).css("margin-top", data.downEnd + data.subH - data.arrowDownH).end().css("visibility", "visible");
                    }
                }
            },
            menuScrollRefreshData: function($sub) {
                var data = $sub.dataSM("scroll"), $win = $(window), vportY = $win.scrollTop() - $sub.dataSM("parent-a").offset().top - data.itemH;
                $.extend(data, {
                    upEnd: vportY,
                    downEnd: vportY + this.getViewportHeight() - data.subH
                });
            },
            menuScrollStop: function($sub) {
                if (this.scrollTimeout) {
                    clearTimeout(this.scrollTimeout);
                    this.scrollTimeout = 0;
                    $.extend($sub.dataSM("scroll"), {
                        step: 1,
                        velocity: 0
                    });
                    return true;
                }
            },
            menuScrollTouch: function($sub, e) {
                e = e.originalEvent;
                if (isTouchEvent(e)) {
                    var touchPoint = this.getTouchPoint(e);
                    // neglect event if we touched a visible deeper level sub menu
                    if (this.getClosestMenu(touchPoint.target) == $sub[0]) {
                        var data = $sub.dataSM("scroll");
                        if (/(start|down)$/i.test(e.type)) {
                            if (this.menuScrollStop($sub)) {
                                // if we were scrolling, just stop and don't activate any link on the first touch
                                e.preventDefault();
                                this.isTouchScrolling = true;
                            } else {
                                this.isTouchScrolling = false;
                            }
                            // update scroll data since the user might have zoomed, etc.
                            this.menuScrollRefreshData($sub);
                            // extend it with the touch properties
                            $.extend(data, {
                                touchY: touchPoint.pageY,
                                touchTimestamp: e.timeStamp,
                                velocity: 0
                            });
                        } else if (/move$/i.test(e.type)) {
                            var prevY = data.touchY;
                            if (prevY !== undefined && prevY != touchPoint.pageY) {
                                this.isTouchScrolling = true;
                                $.extend(data, {
                                    up: prevY < touchPoint.pageY,
                                    touchY: touchPoint.pageY,
                                    touchTimestamp: e.timeStamp,
                                    velocity: data.velocity + Math.abs(touchPoint.pageY - prevY) * .5
                                });
                                this.menuScroll($sub, true, Math.abs(data.touchY - prevY));
                            }
                            e.preventDefault();
                        } else {
                            // touchend/pointerup
                            if (data.touchY !== undefined) {
                                // check if we need to scroll
                                if (e.timeStamp - data.touchTimestamp < 120 && data.velocity > 0) {
                                    data.velocity *= .5;
                                    this.menuScrollStop($sub);
                                    this.menuScroll($sub);
                                    e.preventDefault();
                                }
                                delete data.touchY;
                            }
                        }
                    }
                }
            },
            menuShow: function($sub) {
                if (!$sub.dataSM("beforefirstshowfired")) {
                    $sub.dataSM("beforefirstshowfired", true);
                    if (this.$root.triggerHandler("beforefirstshow.smapi", $sub[0]) === false) {
                        return;
                    }
                }
                if (this.$root.triggerHandler("beforeshow.smapi", $sub[0]) === false) {
                    return;
                }
                this.menuFixLayout($sub);
                $sub.stop(true, true);
                if (!$sub.is(":visible")) {
                    // set z-index
                    $sub.css("z-index", this.zIndexInc = (this.zIndexInc || this.getStartZIndex()) + 1);
                    // highlight parent item
                    if (this.opts.keepHighlighted || this.isCollapsible()) {
                        $sub.dataSM("parent-a").addClass("highlighted");
                    }
                    // min/max-width fix - no way to rely purely on CSS as all UL's are nested
                    if (this.opts.subMenusMinWidth || this.opts.subMenusMaxWidth) {
                        $sub.css({
                            width: "auto",
                            minWidth: "",
                            maxWidth: ""
                        }).addClass("sm-nowrap");
                        if (this.opts.subMenusMinWidth) {
                            $sub.css("min-width", this.opts.subMenusMinWidth);
                        }
                        if (this.opts.subMenusMaxWidth) {
                            var noMaxWidth = this.getWidth($sub);
                            $sub.css("max-width", this.opts.subMenusMaxWidth);
                            if (noMaxWidth > this.getWidth($sub)) {
                                $sub.removeClass("sm-nowrap").css("width", this.opts.subMenusMaxWidth);
                            }
                        }
                    }
                    this.menuPosition($sub);
                    // insert IE iframe shim
                    if ($sub.dataSM("ie-shim")) {
                        $sub.dataSM("ie-shim").insertBefore($sub);
                    }
                    var complete = function() {
                        // fix: "overflow: hidden;" is not reset on animation complete in jQuery < 1.9.0 in Chrome when global "box-sizing: border-box;" is used
                        $sub.css("overflow", "");
                    };
                    // if sub is collapsible (mobile view)
                    if (this.isCollapsible()) {
                        if (this.opts.collapsibleShowFunction) {
                            this.opts.collapsibleShowFunction.call(this, $sub, complete);
                        } else {
                            $sub.show(this.opts.collapsibleShowDuration, complete);
                        }
                    } else {
                        if (this.opts.showFunction) {
                            this.opts.showFunction.call(this, $sub, complete);
                        } else {
                            $sub.show(this.opts.showDuration, complete);
                        }
                    }
                    // save new sub menu for this level
                    this.visibleSubMenus[$sub.dataSM("level") - 1] = $sub;
                    this.$root.triggerHandler("show.smapi", $sub[0]);
                }
            },
            popupHide: function(noHideTimeout) {
                if (this.hideTimeout) {
                    clearTimeout(this.hideTimeout);
                    this.hideTimeout = 0;
                }
                var self = this;
                this.hideTimeout = setTimeout(function() {
                    self.menuHideAll();
                }, noHideTimeout ? 1 : this.opts.hideTimeout);
            },
            popupShow: function(left, top) {
                if (!this.opts.isPopup) {
                    alert('SmartMenus jQuery Error:\n\nIf you want to show this menu via the "popupShow" method, set the isPopup:true option.');
                    return;
                }
                if (this.hideTimeout) {
                    clearTimeout(this.hideTimeout);
                    this.hideTimeout = 0;
                }
                this.menuFixLayout(this.$root);
                this.$root.stop(true, true);
                if (!this.$root.is(":visible")) {
                    this.$root.css({
                        left: left,
                        top: top
                    });
                    // IE iframe shim
                    this.menuIframeShim(this.$root);
                    if (this.$root.dataSM("ie-shim")) {
                        this.$root.dataSM("ie-shim").css({
                            zIndex: this.$root.css("z-index"),
                            width: this.getWidth(this.$root),
                            height: this.getHeight(this.$root),
                            left: left,
                            top: top
                        }).insertBefore(this.$root);
                    }
                    // show menu
                    var self = this, complete = function() {
                        self.$root.css("overflow", "");
                    };
                    if (this.opts.showFunction) {
                        this.opts.showFunction.call(this, this.$root, complete);
                    } else {
                        this.$root.show(this.opts.showDuration, complete);
                    }
                    this.visibleSubMenus[0] = this.$root;
                }
            },
            refresh: function() {
                this.menuHideAll();
                this.$root.find("ul").each(function() {
                    var $this = $(this);
                    if ($this.dataSM("scroll-arrows")) {
                        $this.dataSM("scroll-arrows").remove();
                    }
                }).removeDataSM("in-mega").removeDataSM("shown-before").removeDataSM("ie-shim").removeDataSM("scroll-arrows").removeDataSM("parent-a").removeDataSM("level").removeDataSM("beforefirstshowfired");
                this.$root.find("a.has-submenu").removeClass("has-submenu").parent().removeDataSM("sub");
                if (this.opts.subIndicators) {
                    this.$root.find("span.sub-arrow").remove();
                }
                if (this.opts.markCurrentItem) {
                    this.$root.find("a.current").removeClass("current");
                }
                this.subMenus = [];
                this.init(true);
            },
            rootOut: function(e) {
                if (!this.handleEvents() || this.isTouchMode() || e.target == this.$root[0]) {
                    return;
                }
                if (this.hideTimeout) {
                    clearTimeout(this.hideTimeout);
                    this.hideTimeout = 0;
                }
                if (!this.opts.showOnClick || !this.opts.hideOnClick) {
                    var self = this;
                    this.hideTimeout = setTimeout(function() {
                        self.menuHideAll();
                    }, this.opts.hideTimeout);
                }
            },
            rootOver: function(e) {
                if (!this.handleEvents() || this.isTouchMode() || e.target == this.$root[0]) {
                    return;
                }
                if (this.hideTimeout) {
                    clearTimeout(this.hideTimeout);
                    this.hideTimeout = 0;
                }
            },
            winResize: function(e) {
                if (!this.handleEvents()) {
                    // we still need to resize the disable overlay if it's visible
                    if (this.$disableOverlay) {
                        var pos = this.$root.offset();
                        this.$disableOverlay.css({
                            top: pos.top,
                            left: pos.left,
                            width: this.$root.outerWidth(),
                            height: this.$root.outerHeight()
                        });
                    }
                    return;
                }
                // hide sub menus on resize - on mobile do it only on orientation change
                if (!this.isCollapsible() && (!("onorientationchange" in window) || e.type == "orientationchange")) {
                    if (this.activatedItems.length) {
                        this.activatedItems[this.activatedItems.length - 1][0].blur();
                    }
                    this.menuHideAll();
                }
            }
        }
    });
    $.fn.dataSM = function(key, val) {
        if (val) {
            return this.data(key + "_smartmenus", val);
        }
        return this.data(key + "_smartmenus");
    };
    $.fn.removeDataSM = function(key) {
        return this.removeData(key + "_smartmenus");
    };
    $.fn.smartmenus = function(options) {
        if (typeof options == "string") {
            var args = arguments, method = options;
            Array.prototype.shift.call(args);
            return this.each(function() {
                var smartmenus = $(this).data("smartmenus");
                if (smartmenus && smartmenus[method]) {
                    smartmenus[method].apply(smartmenus, args);
                }
            });
        }
        var opts = $.extend({}, $.fn.smartmenus.defaults, options);
        return this.each(function() {
            new $.SmartMenus(this, opts);
        });
    };
    // default settings
    $.fn.smartmenus.defaults = {
        isPopup: false,
        // is this a popup menu (can be shown via the popupShow/popupHide methods) or a permanent menu bar
        mainMenuSubOffsetX: 0,
        // pixels offset from default position
        mainMenuSubOffsetY: 0,
        // pixels offset from default position
        subMenusSubOffsetX: 0,
        // pixels offset from default position
        subMenusSubOffsetY: 0,
        // pixels offset from default position
        subMenusMinWidth: "10em",
        // min-width for the sub menus (any CSS unit) - if set, the fixed width set in CSS will be ignored
        subMenusMaxWidth: "20em",
        // max-width for the sub menus (any CSS unit) - if set, the fixed width set in CSS will be ignored
        subIndicators: true,
        // create sub menu indicators - creates a SPAN and inserts it in the A
        subIndicatorsPos: "prepend",
        // position of the SPAN relative to the menu item content ('prepend', 'append')
        subIndicatorsText: "+",
        // [optionally] add text in the SPAN (e.g. '+') (you may want to check the CSS for the sub indicators too)
        scrollStep: 30,
        // pixels step when scrolling long sub menus that do not fit in the viewport height
        scrollInterval: 30,
        // interval between each scrolling step
        scrollAccelerate: true,
        // accelerate scrolling or use a fixed step
        showTimeout: 250,
        // timeout before showing the sub menus
        hideTimeout: 500,
        // timeout before hiding the sub menus
        showDuration: 0,
        // duration for show animation - set to 0 for no animation - matters only if showFunction:null
        showFunction: null,
        // custom function to use when showing a sub menu (the default is the jQuery 'show')
        // don't forget to call complete() at the end of whatever you do
        // e.g.: function($ul, complete) { $ul.fadeIn(250, complete); }
        hideDuration: 0,
        // duration for hide animation - set to 0 for no animation - matters only if hideFunction:null
        hideFunction: function($ul, complete) {
            $ul.fadeOut(200, complete);
        },
        // custom function to use when hiding a sub menu (the default is the jQuery 'hide')
        // don't forget to call complete() at the end of whatever you do
        // e.g.: function($ul, complete) { $ul.fadeOut(250, complete); }
        collapsibleShowDuration: 0,
        // duration for show animation for collapsible sub menus - matters only if collapsibleShowFunction:null
        collapsibleShowFunction: function($ul, complete) {
            $ul.slideDown(200, complete);
        },
        // custom function to use when showing a collapsible sub menu
        // (i.e. when mobile styles are used to make the sub menus collapsible)
        collapsibleHideDuration: 0,
        // duration for hide animation for collapsible sub menus - matters only if collapsibleHideFunction:null
        collapsibleHideFunction: function($ul, complete) {
            $ul.slideUp(200, complete);
        },
        // custom function to use when hiding a collapsible sub menu
        // (i.e. when mobile styles are used to make the sub menus collapsible)
        showOnClick: false,
        // show the first-level sub menus onclick instead of onmouseover (matters only for mouse input)
        hideOnClick: true,
        // hide the sub menus on click/tap anywhere on the page
        keepInViewport: true,
        // reposition the sub menus if needed to make sure they always appear inside the viewport
        keepHighlighted: true,
        // keep all ancestor items of the current sub menu highlighted (adds the 'highlighted' class to the A's)
        markCurrentItem: false,
        // automatically add the 'current' class to the A element of the item linking to the current URL
        markCurrentTree: true,
        // add the 'current' class also to the A elements of all ancestor items of the current item
        rightToLeftSubMenus: false,
        // right to left display of the sub menus (check the CSS for the sub indicators' position)
        bottomToTopSubMenus: false,
        // bottom to top display of the sub menus
        overlapControlsInIE: true
    };
})(jQuery);

/*!
 * SmartMenus jQuery Plugin Bootstrap Addon - v0.1.1 - August 25, 2014
 * http://www.smartmenus.org/
 *
 * Copyright 2014 Vasil Dinkov, Vadikom Web Ltd.
 * http://vadikom.com
 *
 * Licensed MIT
 */
(function($) {
    // init ondomready
    $(function() {
        // init all menus
        $("ul.navbar-nav").each(function() {
            var $this = $(this);
            $this.addClass("sm").smartmenus({
                // these are some good default options that should work for all
                // you can, of course, tweak these as you like
                subMenusSubOffsetX: 2,
                subMenusSubOffsetY: -6,
                subIndicatorsPos: "append",
                subIndicatorsText: "...",
                collapsibleShowFunction: null,
                collapsibleHideFunction: null,
                rightToLeftSubMenus: $this.hasClass("navbar-right"),
                bottomToTopSubMenus: $this.closest(".navbar").hasClass("navbar-fixed-bottom")
            }).find("a.current").parent().addClass("active");
        }).bind({
            // set/unset proper Bootstrap classes for some menu elements
            "show.smapi": function(e, menu) {
                var $menu = $(menu), $scrollArrows = $menu.dataSM("scroll-arrows"), obj = $(this).data("smartmenus");
                if ($scrollArrows) {
                    // they inherit border-color from body, so we can use its background-color too
                    $scrollArrows.css("background-color", $(document.body).css("background-color"));
                }
                $menu.parent().addClass("open" + (obj.isCollapsible() ? " collapsible" : ""));
            },
            "hide.smapi": function(e, menu) {
                $(menu).parent().removeClass("open collapsible");
            },
            // click the parent item to toggle the sub menus (and reset deeper levels and other branches on click)
            "click.smapi": function(e, item) {
                var obj = $(this).data("smartmenus");
                if (obj.isCollapsible()) {
                    var $item = $(item), $sub = $item.parent().dataSM("sub");
                    if ($sub && $sub.dataSM("shown-before") && $sub.is(":visible")) {
                        obj.itemActivate($item);
                        obj.menuHide($sub);
                        return false;
                    }
                }
            }
        });
    });
    // fix collapsible menu detection for Bootstrap 3
    $.SmartMenus.prototype.isCollapsible = function() {
        return this.$firstLink.parent().css("float") != "left";
    };
})(jQuery);

/*!
 * headroom.js v0.7.0 - Give your page some headroom. Hide your header until you need it
 * Copyright (c) 2014 Nick Williams - http://wicky.nillia.ms/headroom.js
 * License: MIT
 */
(function(window, document) {
    "use strict";
    /* exported features */
    var features = {
        bind: !!function() {}.bind,
        classList: "classList" in document.documentElement,
        rAF: !!(window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame)
    };
    window.requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame;
    /**
   * Handles debouncing of events via requestAnimationFrame
   * @see http://www.html5rocks.com/en/tutorials/speed/animations/
   * @param {Function} callback The callback to handle whichever event
   */
    function Debouncer(callback) {
        this.callback = callback;
        this.ticking = false;
    }
    Debouncer.prototype = {
        constructor: Debouncer,
        /**
     * dispatches the event to the supplied callback
     * @private
     */
        update: function() {
            this.callback && this.callback();
            this.ticking = false;
        },
        /**
     * ensures events don't get stacked
     * @private
     */
        requestTick: function() {
            if (!this.ticking) {
                requestAnimationFrame(this.rafCallback || (this.rafCallback = this.update.bind(this)));
                this.ticking = true;
            }
        },
        /**
     * Attach this as the event listeners
     */
        handleEvent: function() {
            this.requestTick();
        }
    };
    /**
   * Check if object is part of the DOM
   * @constructor
   * @param {Object} obj element to check
   */
    function isDOMElement(obj) {
        return obj && typeof window !== "undefined" && (obj === window || obj.nodeType);
    }
    /**
   * Helper function for extending objects
   */
    function extend(object) {
        if (arguments.length <= 0) {
            throw new Error("Missing arguments in extend function");
        }
        var result = object || {}, key, i;
        for (i = 1; i < arguments.length; i++) {
            var replacement = arguments[i] || {};
            for (key in replacement) {
                // Recurse into object except if the object is a DOM element
                if (typeof result[key] === "object" && !isDOMElement(result[key])) {
                    result[key] = extend(result[key], replacement[key]);
                } else {
                    result[key] = result[key] || replacement[key];
                }
            }
        }
        return result;
    }
    /**
   * Helper function for normalizing tolerance option to object format
   */
    function normalizeTolerance(t) {
        return t === Object(t) ? t : {
            down: t,
            up: t
        };
    }
    /**
   * UI enhancement for fixed headers.
   * Hides header when scrolling down
   * Shows header when scrolling up
   * @constructor
   * @param {DOMElement} elem the header element
   * @param {Object} options options for the widget
   */
    function Headroom(elem, options) {
        options = extend(options, Headroom.options);
        this.lastKnownScrollY = 0;
        this.elem = elem;
        this.debouncer = new Debouncer(this.update.bind(this));
        this.tolerance = normalizeTolerance(options.tolerance);
        this.classes = options.classes;
        this.offset = options.offset;
        this.scroller = options.scroller;
        this.initialised = false;
        this.onPin = options.onPin;
        this.onUnpin = options.onUnpin;
        this.onTop = options.onTop;
        this.onNotTop = options.onNotTop;
    }
    Headroom.prototype = {
        constructor: Headroom,
        /**
     * Initialises the widget
     */
        init: function() {
            if (!Headroom.cutsTheMustard) {
                return;
            }
            this.elem.classList.add(this.classes.initial);
            // defer event registration to handle browser 
            // potentially restoring previous scroll position
            setTimeout(this.attachEvent.bind(this), 100);
            return this;
        },
        /**
     * Unattaches events and removes any classes that were added
     */
        destroy: function() {
            var classes = this.classes;
            this.initialised = false;
            this.elem.classList.remove(classes.unpinned, classes.pinned, classes.top, classes.initial);
            this.scroller.removeEventListener("scroll", this.debouncer, false);
        },
        /**
     * Attaches the scroll event
     * @private
     */
        attachEvent: function() {
            if (!this.initialised) {
                this.lastKnownScrollY = this.getScrollY();
                this.initialised = true;
                this.scroller.addEventListener("scroll", this.debouncer, false);
                this.debouncer.handleEvent();
            }
        },
        /**
     * Unpins the header if it's currently pinned
     */
        unpin: function() {
            var classList = this.elem.classList, classes = this.classes;
            if (classList.contains(classes.pinned) || !classList.contains(classes.unpinned)) {
                classList.add(classes.unpinned);
                classList.remove(classes.pinned);
                this.onUnpin && this.onUnpin.call(this);
            }
        },
        /**
     * Pins the header if it's currently unpinned
     */
        pin: function() {
            var classList = this.elem.classList, classes = this.classes;
            if (classList.contains(classes.unpinned)) {
                classList.remove(classes.unpinned);
                classList.add(classes.pinned);
                this.onPin && this.onPin.call(this);
            }
        },
        /**
     * Handles the top states
     */
        top: function() {
            var classList = this.elem.classList, classes = this.classes;
            if (!classList.contains(classes.top)) {
                classList.add(classes.top);
                classList.remove(classes.notTop);
                this.onTop && this.onTop.call(this);
            }
        },
        /**
     * Handles the not top state
     */
        notTop: function() {
            var classList = this.elem.classList, classes = this.classes;
            if (!classList.contains(classes.notTop)) {
                classList.add(classes.notTop);
                classList.remove(classes.top);
                this.onNotTop && this.onNotTop.call(this);
            }
        },
        /**
     * Gets the Y scroll position
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Window.scrollY
     * @return {Number} pixels the page has scrolled along the Y-axis
     */
        getScrollY: function() {
            return this.scroller.pageYOffset !== undefined ? this.scroller.pageYOffset : this.scroller.scrollTop !== undefined ? this.scroller.scrollTop : (document.documentElement || document.body.parentNode || document.body).scrollTop;
        },
        /**
     * Gets the height of the viewport
     * @see http://andylangton.co.uk/blog/development/get-viewport-size-width-and-height-javascript
     * @return {int} the height of the viewport in pixels
     */
        getViewportHeight: function() {
            return window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
        },
        /**
     * Gets the height of the document
     * @see http://james.padolsey.com/javascript/get-document-height-cross-browser/
     * @return {int} the height of the document in pixels
     */
        getDocumentHeight: function() {
            var body = document.body, documentElement = document.documentElement;
            return Math.max(body.scrollHeight, documentElement.scrollHeight, body.offsetHeight, documentElement.offsetHeight, body.clientHeight, documentElement.clientHeight);
        },
        /**
     * Gets the height of the DOM element
     * @param  {Object}  elm the element to calculate the height of which
     * @return {int}     the height of the element in pixels
     */
        getElementHeight: function(elm) {
            return Math.max(elm.scrollHeight, elm.offsetHeight, elm.clientHeight);
        },
        /**
     * Gets the height of the scroller element
     * @return {int} the height of the scroller element in pixels
     */
        getScrollerHeight: function() {
            return this.scroller === window || this.scroller === document.body ? this.getDocumentHeight() : this.getElementHeight(this.scroller);
        },
        /**
     * determines if the scroll position is outside of document boundaries
     * @param  {int}  currentScrollY the current y scroll position
     * @return {bool} true if out of bounds, false otherwise
     */
        isOutOfBounds: function(currentScrollY) {
            var pastTop = currentScrollY < 0, pastBottom = currentScrollY + this.getViewportHeight() > this.getScrollerHeight();
            return pastTop || pastBottom;
        },
        /**
     * determines if the tolerance has been exceeded
     * @param  {int} currentScrollY the current scroll y position
     * @return {bool} true if tolerance exceeded, false otherwise
     */
        toleranceExceeded: function(currentScrollY, direction) {
            return Math.abs(currentScrollY - this.lastKnownScrollY) >= this.tolerance[direction];
        },
        /**
     * determine if it is appropriate to unpin
     * @param  {int} currentScrollY the current y scroll position
     * @param  {bool} toleranceExceeded has the tolerance been exceeded?
     * @return {bool} true if should unpin, false otherwise
     */
        shouldUnpin: function(currentScrollY, toleranceExceeded) {
            var scrollingDown = currentScrollY > this.lastKnownScrollY, pastOffset = currentScrollY >= this.offset;
            return scrollingDown && pastOffset && toleranceExceeded;
        },
        /**
     * determine if it is appropriate to pin
     * @param  {int} currentScrollY the current y scroll position
     * @param  {bool} toleranceExceeded has the tolerance been exceeded?
     * @return {bool} true if should pin, false otherwise
     */
        shouldPin: function(currentScrollY, toleranceExceeded) {
            var scrollingUp = currentScrollY < this.lastKnownScrollY, pastOffset = currentScrollY <= this.offset;
            return scrollingUp && toleranceExceeded || pastOffset;
        },
        /**
     * Handles updating the state of the widget
     */
        update: function() {
            var currentScrollY = this.getScrollY(), scrollDirection = currentScrollY > this.lastKnownScrollY ? "down" : "up", toleranceExceeded = this.toleranceExceeded(currentScrollY, scrollDirection);
            if (this.isOutOfBounds(currentScrollY)) {
                // Ignore bouncy scrolling in OSX
                return;
            }
            if (currentScrollY <= this.offset) {
                this.top();
            } else {
                this.notTop();
            }
            if (this.shouldUnpin(currentScrollY, toleranceExceeded)) {
                this.unpin();
            } else if (this.shouldPin(currentScrollY, toleranceExceeded)) {
                this.pin();
            }
            this.lastKnownScrollY = currentScrollY;
        }
    };
    /**
   * Default options
   * @type {Object}
   */
    Headroom.options = {
        tolerance: {
            up: 0,
            down: 0
        },
        offset: 0,
        scroller: window,
        classes: {
            pinned: "headroom--pinned",
            unpinned: "headroom--unpinned",
            top: "headroom--top",
            notTop: "headroom--not-top",
            initial: "headroom"
        }
    };
    Headroom.cutsTheMustard = typeof features !== "undefined" && features.rAF && features.bind && features.classList;
    window.Headroom = Headroom;
})(window, document);

/*!
 * headroom.js v0.7.0 - Give your page some headroom. Hide your header until you need it
 * Copyright (c) 2014 Nick Williams - http://wicky.nillia.ms/headroom.js
 * License: MIT
 */
(function($) {
    if (!$) {
        return;
    }
    ////////////
    // Plugin //
    ////////////
    $.fn.headroom = function(option) {
        return this.each(function() {
            var $this = $(this), data = $this.data("headroom"), options = typeof option === "object" && option;
            options = $.extend(true, {}, Headroom.options, options);
            if (!data) {
                data = new Headroom(this, options);
                data.init();
                $this.data("headroom", data);
            }
            if (typeof option === "string") {
                data[option]();
            }
        });
    };
    //////////////
    // Data API //
    //////////////
    $("[data-headroom]").each(function() {
        var $this = $(this);
        $this.headroom($this.data());
    });
})(window.Zepto || window.jQuery);

/*!
 * Bootstrap-select v1.7.7 (http://silviomoreto.github.io/bootstrap-select)
 *
 * Copyright 2013-2015 bootstrap-select
 * Licensed under MIT (https://github.com/silviomoreto/bootstrap-select/blob/master/LICENSE)
 */
(function(root, factory) {
    if (typeof define === "function" && define.amd) {
        // AMD. Register as an anonymous module unless amdModuleId is set
        define([ "jquery" ], function(a0) {
            return factory(a0);
        });
    } else if (typeof exports === "object") {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like environments that support module.exports,
        // like Node.
        module.exports = factory(require("jquery"));
    } else {
        factory(jQuery);
    }
})(this, function(jQuery) {
    (function($) {
        "use strict";
        //<editor-fold desc="Shims">
        if (!String.prototype.includes) {
            (function() {
                "use strict";
                // needed to support `apply`/`call` with `undefined`/`null`
                var toString = {}.toString;
                var defineProperty = function() {
                    // IE 8 only supports `Object.defineProperty` on DOM elements
                    try {
                        var object = {};
                        var $defineProperty = Object.defineProperty;
                        var result = $defineProperty(object, object, object) && $defineProperty;
                    } catch (error) {}
                    return result;
                }();
                var indexOf = "".indexOf;
                var includes = function(search) {
                    if (this == null) {
                        throw new TypeError();
                    }
                    var string = String(this);
                    if (search && toString.call(search) == "[object RegExp]") {
                        throw new TypeError();
                    }
                    var stringLength = string.length;
                    var searchString = String(search);
                    var searchLength = searchString.length;
                    var position = arguments.length > 1 ? arguments[1] : undefined;
                    // `ToInteger`
                    var pos = position ? Number(position) : 0;
                    if (pos != pos) {
                        // better `isNaN`
                        pos = 0;
                    }
                    var start = Math.min(Math.max(pos, 0), stringLength);
                    // Avoid the `indexOf` call if no match is possible
                    if (searchLength + start > stringLength) {
                        return false;
                    }
                    return indexOf.call(string, searchString, pos) != -1;
                };
                if (defineProperty) {
                    defineProperty(String.prototype, "includes", {
                        value: includes,
                        configurable: true,
                        writable: true
                    });
                } else {
                    String.prototype.includes = includes;
                }
            })();
        }
        if (!String.prototype.startsWith) {
            (function() {
                "use strict";
                // needed to support `apply`/`call` with `undefined`/`null`
                var defineProperty = function() {
                    // IE 8 only supports `Object.defineProperty` on DOM elements
                    try {
                        var object = {};
                        var $defineProperty = Object.defineProperty;
                        var result = $defineProperty(object, object, object) && $defineProperty;
                    } catch (error) {}
                    return result;
                }();
                var toString = {}.toString;
                var startsWith = function(search) {
                    if (this == null) {
                        throw new TypeError();
                    }
                    var string = String(this);
                    if (search && toString.call(search) == "[object RegExp]") {
                        throw new TypeError();
                    }
                    var stringLength = string.length;
                    var searchString = String(search);
                    var searchLength = searchString.length;
                    var position = arguments.length > 1 ? arguments[1] : undefined;
                    // `ToInteger`
                    var pos = position ? Number(position) : 0;
                    if (pos != pos) {
                        // better `isNaN`
                        pos = 0;
                    }
                    var start = Math.min(Math.max(pos, 0), stringLength);
                    // Avoid the `indexOf` call if no match is possible
                    if (searchLength + start > stringLength) {
                        return false;
                    }
                    var index = -1;
                    while (++index < searchLength) {
                        if (string.charCodeAt(start + index) != searchString.charCodeAt(index)) {
                            return false;
                        }
                    }
                    return true;
                };
                if (defineProperty) {
                    defineProperty(String.prototype, "startsWith", {
                        value: startsWith,
                        configurable: true,
                        writable: true
                    });
                } else {
                    String.prototype.startsWith = startsWith;
                }
            })();
        }
        if (!Object.keys) {
            Object.keys = function(o, // object
            k, // key
            r) {
                // initialize object and result
                r = [];
                // iterate over object keys
                for (k in o) // fill result array with non-prototypical keys
                r.hasOwnProperty.call(o, k) && r.push(k);
                // return result
                return r;
            };
        }
        $.fn.triggerNative = function(eventName) {
            var el = this[0], event;
            if (el.dispatchEvent) {
                if (typeof Event === "function") {
                    // For modern browsers
                    event = new Event(eventName, {
                        bubbles: true
                    });
                } else {
                    // For IE since it doesn't support Event constructor
                    event = document.createEvent("Event");
                    event.initEvent(eventName, true, false);
                }
                el.dispatchEvent(event);
            } else {
                if (el.fireEvent) {
                    event = document.createEventObject();
                    event.eventType = eventName;
                    el.fireEvent("on" + eventName, event);
                }
                this.trigger(eventName);
            }
        };
        //</editor-fold>
        // Case insensitive contains search
        $.expr[":"].icontains = function(obj, index, meta) {
            var $obj = $(obj);
            var haystack = ($obj.data("tokens") || $obj.text()).toUpperCase();
            return haystack.includes(meta[3].toUpperCase());
        };
        // Case insensitive begins search
        $.expr[":"].ibegins = function(obj, index, meta) {
            var $obj = $(obj);
            var haystack = ($obj.data("tokens") || $obj.text()).toUpperCase();
            return haystack.startsWith(meta[3].toUpperCase());
        };
        // Case and accent insensitive contains search
        $.expr[":"].aicontains = function(obj, index, meta) {
            var $obj = $(obj);
            var haystack = ($obj.data("tokens") || $obj.data("normalizedText") || $obj.text()).toUpperCase();
            return haystack.includes(meta[3].toUpperCase());
        };
        // Case and accent insensitive begins search
        $.expr[":"].aibegins = function(obj, index, meta) {
            var $obj = $(obj);
            var haystack = ($obj.data("tokens") || $obj.data("normalizedText") || $obj.text()).toUpperCase();
            return haystack.startsWith(meta[3].toUpperCase());
        };
        /**
   * Remove all diatrics from the given text.
   * @access private
   * @param {String} text
   * @returns {String}
   */
        function normalizeToBase(text) {
            var rExps = [ {
                re: /[\xC0-\xC6]/g,
                ch: "A"
            }, {
                re: /[\xE0-\xE6]/g,
                ch: "a"
            }, {
                re: /[\xC8-\xCB]/g,
                ch: "E"
            }, {
                re: /[\xE8-\xEB]/g,
                ch: "e"
            }, {
                re: /[\xCC-\xCF]/g,
                ch: "I"
            }, {
                re: /[\xEC-\xEF]/g,
                ch: "i"
            }, {
                re: /[\xD2-\xD6]/g,
                ch: "O"
            }, {
                re: /[\xF2-\xF6]/g,
                ch: "o"
            }, {
                re: /[\xD9-\xDC]/g,
                ch: "U"
            }, {
                re: /[\xF9-\xFC]/g,
                ch: "u"
            }, {
                re: /[\xC7-\xE7]/g,
                ch: "c"
            }, {
                re: /[\xD1]/g,
                ch: "N"
            }, {
                re: /[\xF1]/g,
                ch: "n"
            } ];
            $.each(rExps, function() {
                text = text.replace(this.re, this.ch);
            });
            return text;
        }
        function htmlEscape(html) {
            var escapeMap = {
                "&": "&amp;",
                "<": "&lt;",
                ">": "&gt;",
                '"': "&quot;",
                "'": "&#x27;",
                "`": "&#x60;"
            };
            var source = "(?:" + Object.keys(escapeMap).join("|") + ")", testRegexp = new RegExp(source), replaceRegexp = new RegExp(source, "g"), string = html == null ? "" : "" + html;
            return testRegexp.test(string) ? string.replace(replaceRegexp, function(match) {
                return escapeMap[match];
            }) : string;
        }
        var Selectpicker = function(element, options, e) {
            if (e) {
                e.stopPropagation();
                e.preventDefault();
            }
            this.$element = $(element);
            this.$newElement = null;
            this.$button = null;
            this.$menu = null;
            this.$lis = null;
            this.options = options;
            // If we have no title yet, try to pull it from the html title attribute (jQuery doesnt' pick it up as it's not a
            // data-attribute)
            if (this.options.title === null) {
                this.options.title = this.$element.attr("title");
            }
            //Expose public methods
            this.val = Selectpicker.prototype.val;
            this.render = Selectpicker.prototype.render;
            this.refresh = Selectpicker.prototype.refresh;
            this.setStyle = Selectpicker.prototype.setStyle;
            this.selectAll = Selectpicker.prototype.selectAll;
            this.deselectAll = Selectpicker.prototype.deselectAll;
            this.destroy = Selectpicker.prototype.destroy;
            this.remove = Selectpicker.prototype.remove;
            this.show = Selectpicker.prototype.show;
            this.hide = Selectpicker.prototype.hide;
            this.init();
        };
        Selectpicker.VERSION = "1.7.7";
        // part of this is duplicated in i18n/defaults-en_US.js. Make sure to update both.
        Selectpicker.DEFAULTS = {
            noneSelectedText: "Nothing selected",
            noneResultsText: "No results matched {0}",
            countSelectedText: function(numSelected, numTotal) {
                return numSelected == 1 ? "{0} item selected" : "{0} items selected";
            },
            maxOptionsText: function(numAll, numGroup) {
                return [ numAll == 1 ? "Limit reached ({n} item max)" : "Limit reached ({n} items max)", numGroup == 1 ? "Group limit reached ({n} item max)" : "Group limit reached ({n} items max)" ];
            },
            selectAllText: "Select All",
            deselectAllText: "Deselect All",
            doneButton: false,
            doneButtonText: "Close",
            multipleSeparator: ", ",
            styleBase: "btn",
            style: "btn-default",
            size: "auto",
            title: null,
            selectedTextFormat: "values",
            width: false,
            container: false,
            hideDisabled: false,
            showSubtext: false,
            showIcon: true,
            showContent: true,
            dropupAuto: true,
            header: false,
            liveSearch: false,
            liveSearchPlaceholder: null,
            liveSearchNormalize: false,
            liveSearchStyle: "contains",
            actionsBox: false,
            iconBase: "glyphicon",
            tickIcon: "glyphicon-ok",
            template: {
                caret: '<span class="caret"></span>'
            },
            maxOptions: false,
            mobile: false,
            selectOnTab: false,
            dropdownAlignRight: false
        };
        Selectpicker.prototype = {
            constructor: Selectpicker,
            init: function() {
                var that = this, id = this.$element.attr("id");
                this.$element.addClass("bs-select-hidden");
                // store originalIndex (key) and newIndex (value) in this.liObj for fast accessibility
                // allows us to do this.$lis.eq(that.liObj[index]) instead of this.$lis.filter('[data-original-index="' + index + '"]')
                this.liObj = {};
                this.multiple = this.$element.prop("multiple");
                this.autofocus = this.$element.prop("autofocus");
                this.$newElement = this.createView();
                this.$element.after(this.$newElement);
                this.$button = this.$newElement.children("button");
                this.$menu = this.$newElement.children(".dropdown-menu");
                this.$menuInner = this.$menu.children(".inner");
                this.$searchbox = this.$menu.find("input");
                if (this.options.dropdownAlignRight) this.$menu.addClass("dropdown-menu-right");
                if (typeof id !== "undefined") {
                    this.$button.attr("data-id", id);
                    $('label[for="' + id + '"]').click(function(e) {
                        e.preventDefault();
                        that.$button.focus();
                    });
                }
                this.checkDisabled();
                this.clickListener();
                if (this.options.liveSearch) this.liveSearchListener();
                this.render();
                this.setStyle();
                this.setWidth();
                if (this.options.container) this.selectPosition();
                this.$menu.data("this", this);
                this.$newElement.data("this", this);
                if (this.options.mobile) this.mobile();
                this.$newElement.on({
                    "hide.bs.dropdown": function(e) {
                        that.$element.trigger("hide.bs.select", e);
                    },
                    "hidden.bs.dropdown": function(e) {
                        that.$element.trigger("hidden.bs.select", e);
                    },
                    "show.bs.dropdown": function(e) {
                        that.$element.trigger("show.bs.select", e);
                    },
                    "shown.bs.dropdown": function(e) {
                        that.$element.trigger("shown.bs.select", e);
                    }
                });
                setTimeout(function() {
                    that.$element.trigger("loaded.bs.select");
                });
            },
            createDropdown: function() {
                // Options
                // If we are multiple, then add the show-tick class by default
                var multiple = this.multiple ? " show-tick" : "", inputGroup = this.$element.parent().hasClass("input-group") ? " input-group-btn" : "", autofocus = this.autofocus ? " autofocus" : "";
                // Elements
                var header = this.options.header ? '<div class="popover-title"><button type="button" class="close" aria-hidden="true">&times;</button>' + this.options.header + "</div>" : "";
                var searchbox = this.options.liveSearch ? '<div class="bs-searchbox">' + '<input type="text" class="form-control" autocomplete="off"' + (null === this.options.liveSearchPlaceholder ? "" : ' placeholder="' + htmlEscape(this.options.liveSearchPlaceholder) + '"') + ">" + "</div>" : "";
                var actionsbox = this.multiple && this.options.actionsBox ? '<div class="bs-actionsbox">' + '<div class="btn-group btn-group-sm btn-block">' + '<button type="button" class="actions-btn bs-select-all btn btn-default">' + this.options.selectAllText + "</button>" + '<button type="button" class="actions-btn bs-deselect-all btn btn-default">' + this.options.deselectAllText + "</button>" + "</div>" + "</div>" : "";
                var donebutton = this.multiple && this.options.doneButton ? '<div class="bs-donebutton">' + '<div class="btn-group btn-block">' + '<button type="button" class="btn btn-sm btn-default">' + this.options.doneButtonText + "</button>" + "</div>" + "</div>" : "";
                var drop = '<div class="btn-group bootstrap-select' + multiple + inputGroup + '">' + '<button type="button" class="' + this.options.styleBase + ' dropdown-toggle" data-toggle="dropdown"' + autofocus + ">" + '<span class="filter-option pull-left"></span>&nbsp;' + '<span class="bs-caret">' + this.options.template.caret + "</span>" + "</button>" + '<div class="dropdown-menu open">' + header + searchbox + actionsbox + '<ul class="dropdown-menu inner" role="menu">' + "</ul>" + donebutton + "</div>" + "</div>";
                return $(drop);
            },
            createView: function() {
                var $drop = this.createDropdown(), li = this.createLi();
                $drop.find("ul")[0].innerHTML = li;
                return $drop;
            },
            reloadLi: function() {
                //Remove all children.
                this.destroyLi();
                //Re build
                var li = this.createLi();
                this.$menuInner[0].innerHTML = li;
            },
            destroyLi: function() {
                this.$menu.find("li").remove();
            },
            createLi: function() {
                var that = this, _li = [], optID = 0, titleOption = document.createElement("option"), liIndex = -1;
                // increment liIndex whenever a new <li> element is created to ensure liObj is correct
                // Helper functions
                /**
       * @param content
       * @param [index]
       * @param [classes]
       * @param [optgroup]
       * @returns {string}
       */
                var generateLI = function(content, index, classes, optgroup) {
                    return "<li" + (typeof classes !== "undefined" & "" !== classes ? ' class="' + classes + '"' : "") + (typeof index !== "undefined" & null !== index ? ' data-original-index="' + index + '"' : "") + (typeof optgroup !== "undefined" & null !== optgroup ? 'data-optgroup="' + optgroup + '"' : "") + ">" + content + "</li>";
                };
                /**
       * @param text
       * @param [classes]
       * @param [inline]
       * @param [tokens]
       * @returns {string}
       */
                var generateA = function(text, classes, inline, tokens) {
                    return '<a tabindex="0"' + (typeof classes !== "undefined" ? ' class="' + classes + '"' : "") + (typeof inline !== "undefined" ? ' style="' + inline + '"' : "") + (that.options.liveSearchNormalize ? ' data-normalized-text="' + normalizeToBase(htmlEscape(text)) + '"' : "") + (typeof tokens !== "undefined" || tokens !== null ? ' data-tokens="' + tokens + '"' : "") + ">" + text + '<span class="' + that.options.iconBase + " " + that.options.tickIcon + ' check-mark"></span>' + "</a>";
                };
                if (this.options.title && !this.multiple) {
                    // this option doesn't create a new <li> element, but does add a new option, so liIndex is decreased
                    // since liObj is recalculated on every refresh, liIndex needs to be decreased even if the titleOption is already appended
                    liIndex--;
                    if (!this.$element.find(".bs-title-option").length) {
                        // Use native JS to prepend option (faster)
                        var element = this.$element[0];
                        titleOption.className = "bs-title-option";
                        titleOption.appendChild(document.createTextNode(this.options.title));
                        titleOption.value = "";
                        element.insertBefore(titleOption, element.firstChild);
                        // Check if selected attribute is already set on an option. If not, select the titleOption option.
                        if ($(element.options[element.selectedIndex]).attr("selected") === undefined) titleOption.selected = true;
                    }
                }
                this.$element.find("option").each(function(index) {
                    var $this = $(this);
                    liIndex++;
                    if ($this.hasClass("bs-title-option")) return;
                    // Get the class and text for the option
                    var optionClass = this.className || "", inline = this.style.cssText, text = $this.data("content") ? $this.data("content") : $this.html(), tokens = $this.data("tokens") ? $this.data("tokens") : null, subtext = typeof $this.data("subtext") !== "undefined" ? '<small class="text-muted">' + $this.data("subtext") + "</small>" : "", icon = typeof $this.data("icon") !== "undefined" ? '<span class="' + that.options.iconBase + " " + $this.data("icon") + '"></span> ' : "", isDisabled = this.disabled || this.parentNode.tagName === "OPTGROUP" && this.parentNode.disabled;
                    if (icon !== "" && isDisabled) {
                        icon = "<span>" + icon + "</span>";
                    }
                    if (that.options.hideDisabled && isDisabled) {
                        liIndex--;
                        return;
                    }
                    if (!$this.data("content")) {
                        // Prepend any icon and append any subtext to the main text.
                        text = icon + '<span class="text">' + text + subtext + "</span>";
                    }
                    if (this.parentNode.tagName === "OPTGROUP" && $this.data("divider") !== true) {
                        var optGroupClass = " " + this.parentNode.className || "";
                        if ($this.index() === 0) {
                            // Is it the first option of the optgroup?
                            optID += 1;
                            // Get the opt group label
                            var label = this.parentNode.label, labelSubtext = typeof $this.parent().data("subtext") !== "undefined" ? '<small class="text-muted">' + $this.parent().data("subtext") + "</small>" : "", labelIcon = $this.parent().data("icon") ? '<span class="' + that.options.iconBase + " " + $this.parent().data("icon") + '"></span> ' : "";
                            label = labelIcon + '<span class="text">' + label + labelSubtext + "</span>";
                            if (index !== 0 && _li.length > 0) {
                                // Is it NOT the first option of the select && are there elements in the dropdown?
                                liIndex++;
                                _li.push(generateLI("", null, "divider", optID + "div"));
                            }
                            liIndex++;
                            _li.push(generateLI(label, null, "dropdown-header" + optGroupClass, optID));
                        }
                        _li.push(generateLI(generateA(text, "opt " + optionClass + optGroupClass, inline, tokens), index, "", optID));
                    } else if ($this.data("divider") === true) {
                        _li.push(generateLI("", index, "divider"));
                    } else if ($this.data("hidden") === true) {
                        _li.push(generateLI(generateA(text, optionClass, inline, tokens), index, "hidden is-hidden"));
                    } else {
                        if (this.previousElementSibling && this.previousElementSibling.tagName === "OPTGROUP") {
                            liIndex++;
                            _li.push(generateLI("", null, "divider", optID + "div"));
                        }
                        _li.push(generateLI(generateA(text, optionClass, inline, tokens), index));
                    }
                    that.liObj[index] = liIndex;
                });
                //If we are not multiple, we don't have a selected item, and we don't have a title, select the first element so something is set in the button
                if (!this.multiple && this.$element.find("option:selected").length === 0 && !this.options.title) {
                    this.$element.find("option").eq(0).prop("selected", true).attr("selected", "selected");
                }
                return _li.join("");
            },
            findLis: function() {
                if (this.$lis == null) this.$lis = this.$menu.find("li");
                return this.$lis;
            },
            /**
     * @param [updateLi] defaults to true
     */
            render: function(updateLi) {
                var that = this, notDisabled;
                //Update the LI to match the SELECT
                if (updateLi !== false) {
                    this.$element.find("option").each(function(index) {
                        var $lis = that.findLis().eq(that.liObj[index]);
                        that.setDisabled(index, this.disabled || this.parentNode.tagName === "OPTGROUP" && this.parentNode.disabled, $lis);
                        that.setSelected(index, this.selected, $lis);
                    });
                }
                this.tabIndex();
                var selectedItems = this.$element.find("option").map(function() {
                    if (this.selected) {
                        if (that.options.hideDisabled && (this.disabled || this.parentNode.tagName === "OPTGROUP" && this.parentNode.disabled)) return;
                        var $this = $(this), icon = $this.data("icon") && that.options.showIcon ? '<i class="' + that.options.iconBase + " " + $this.data("icon") + '"></i> ' : "", subtext;
                        if (that.options.showSubtext && $this.data("subtext") && !that.multiple) {
                            subtext = ' <small class="text-muted">' + $this.data("subtext") + "</small>";
                        } else {
                            subtext = "";
                        }
                        if (typeof $this.attr("title") !== "undefined") {
                            return $this.attr("title");
                        } else if ($this.data("content") && that.options.showContent) {
                            return $this.data("content");
                        } else {
                            return icon + $this.html() + subtext;
                        }
                    }
                }).toArray();
                //Fixes issue in IE10 occurring when no default option is selected and at least one option is disabled
                //Convert all the values into a comma delimited string
                var title = !this.multiple ? selectedItems[0] : selectedItems.join(this.options.multipleSeparator);
                //If this is multi select, and the selectText type is count, the show 1 of 2 selected etc..
                if (this.multiple && this.options.selectedTextFormat.indexOf("count") > -1) {
                    var max = this.options.selectedTextFormat.split(">");
                    if (max.length > 1 && selectedItems.length > max[1] || max.length == 1 && selectedItems.length >= 2) {
                        notDisabled = this.options.hideDisabled ? ", [disabled]" : "";
                        var totalCount = this.$element.find("option").not('[data-divider="true"], [data-hidden="true"]' + notDisabled).length, tr8nText = typeof this.options.countSelectedText === "function" ? this.options.countSelectedText(selectedItems.length, totalCount) : this.options.countSelectedText;
                        title = tr8nText.replace("{0}", selectedItems.length.toString()).replace("{1}", totalCount.toString());
                    }
                }
                if (this.options.title == undefined) {
                    this.options.title = this.$element.attr("title");
                }
                if (this.options.selectedTextFormat == "static") {
                    title = this.options.title;
                }
                //If we dont have a title, then use the default, or if nothing is set at all, use the not selected text
                if (!title) {
                    title = typeof this.options.title !== "undefined" ? this.options.title : this.options.noneSelectedText;
                }
                //strip all html-tags and trim the result
                this.$button.attr("title", $.trim(title.replace(/<[^>]*>?/g, "")));
                this.$button.children(".filter-option").html(title);
                this.$element.trigger("rendered.bs.select");
            },
            /**
     * @param [style]
     * @param [status]
     */
            setStyle: function(style, status) {
                if (this.$element.attr("class")) {
                    this.$newElement.addClass(this.$element.attr("class").replace(/selectpicker|mobile-device|bs-select-hidden|validate\[.*\]/gi, ""));
                }
                var buttonClass = style ? style : this.options.style;
                if (status == "add") {
                    this.$button.addClass(buttonClass);
                } else if (status == "remove") {
                    this.$button.removeClass(buttonClass);
                } else {
                    this.$button.removeClass(this.options.style);
                    this.$button.addClass(buttonClass);
                }
            },
            liHeight: function(refresh) {
                if (!refresh && (this.options.size === false || this.sizeInfo)) return;
                var newElement = document.createElement("div"), menu = document.createElement("div"), menuInner = document.createElement("ul"), divider = document.createElement("li"), li = document.createElement("li"), a = document.createElement("a"), text = document.createElement("span"), header = this.options.header && this.$menu.find(".popover-title").length > 0 ? this.$menu.find(".popover-title")[0].cloneNode(true) : null, search = this.options.liveSearch ? document.createElement("div") : null, actions = this.options.actionsBox && this.multiple && this.$menu.find(".bs-actionsbox").length > 0 ? this.$menu.find(".bs-actionsbox")[0].cloneNode(true) : null, doneButton = this.options.doneButton && this.multiple && this.$menu.find(".bs-donebutton").length > 0 ? this.$menu.find(".bs-donebutton")[0].cloneNode(true) : null;
                text.className = "text";
                newElement.className = this.$menu[0].parentNode.className + " open";
                menu.className = "dropdown-menu open";
                menuInner.className = "dropdown-menu inner";
                divider.className = "divider";
                text.appendChild(document.createTextNode("Inner text"));
                a.appendChild(text);
                li.appendChild(a);
                menuInner.appendChild(li);
                menuInner.appendChild(divider);
                if (header) menu.appendChild(header);
                if (search) {
                    // create a span instead of input as creating an input element is slower
                    var input = document.createElement("span");
                    search.className = "bs-searchbox";
                    input.className = "form-control";
                    search.appendChild(input);
                    menu.appendChild(search);
                }
                if (actions) menu.appendChild(actions);
                menu.appendChild(menuInner);
                if (doneButton) menu.appendChild(doneButton);
                newElement.appendChild(menu);
                document.body.appendChild(newElement);
                var liHeight = a.offsetHeight, headerHeight = header ? header.offsetHeight : 0, searchHeight = search ? search.offsetHeight : 0, actionsHeight = actions ? actions.offsetHeight : 0, doneButtonHeight = doneButton ? doneButton.offsetHeight : 0, dividerHeight = $(divider).outerHeight(true), // fall back to jQuery if getComputedStyle is not supported
                menuStyle = typeof getComputedStyle === "function" ? getComputedStyle(menu) : false, $menu = menuStyle ? null : $(menu), menuPadding = parseInt(menuStyle ? menuStyle.paddingTop : $menu.css("paddingTop")) + parseInt(menuStyle ? menuStyle.paddingBottom : $menu.css("paddingBottom")) + parseInt(menuStyle ? menuStyle.borderTopWidth : $menu.css("borderTopWidth")) + parseInt(menuStyle ? menuStyle.borderBottomWidth : $menu.css("borderBottomWidth")), menuExtras = menuPadding + parseInt(menuStyle ? menuStyle.marginTop : $menu.css("marginTop")) + parseInt(menuStyle ? menuStyle.marginBottom : $menu.css("marginBottom")) + 2;
                document.body.removeChild(newElement);
                this.sizeInfo = {
                    liHeight: liHeight,
                    headerHeight: headerHeight,
                    searchHeight: searchHeight,
                    actionsHeight: actionsHeight,
                    doneButtonHeight: doneButtonHeight,
                    dividerHeight: dividerHeight,
                    menuPadding: menuPadding,
                    menuExtras: menuExtras
                };
            },
            setSize: function() {
                this.findLis();
                this.liHeight();
                if (this.options.header) this.$menu.css("padding-top", 0);
                if (this.options.size === false) return;
                var that = this, $menu = this.$menu, $menuInner = this.$menuInner, $window = $(window), selectHeight = this.$newElement[0].offsetHeight, liHeight = this.sizeInfo["liHeight"], headerHeight = this.sizeInfo["headerHeight"], searchHeight = this.sizeInfo["searchHeight"], actionsHeight = this.sizeInfo["actionsHeight"], doneButtonHeight = this.sizeInfo["doneButtonHeight"], divHeight = this.sizeInfo["dividerHeight"], menuPadding = this.sizeInfo["menuPadding"], menuExtras = this.sizeInfo["menuExtras"], notDisabled = this.options.hideDisabled ? ".disabled" : "", menuHeight, getHeight, selectOffsetTop, selectOffsetBot, posVert = function() {
                    selectOffsetTop = that.$newElement.offset().top - $window.scrollTop();
                    selectOffsetBot = $window.height() - selectOffsetTop - selectHeight;
                };
                posVert();
                if (this.options.size === "auto") {
                    var getSize = function() {
                        var minHeight, hasClass = function(className, include) {
                            return function(element) {
                                if (include) {
                                    return element.classList ? element.classList.contains(className) : $(element).hasClass(className);
                                } else {
                                    return !(element.classList ? element.classList.contains(className) : $(element).hasClass(className));
                                }
                            };
                        }, lis = that.$menuInner[0].getElementsByTagName("li"), lisVisible = Array.prototype.filter ? Array.prototype.filter.call(lis, hasClass("hidden", false)) : that.$lis.not(".hidden"), optGroup = Array.prototype.filter ? Array.prototype.filter.call(lisVisible, hasClass("dropdown-header", true)) : lisVisible.filter(".dropdown-header");
                        posVert();
                        menuHeight = selectOffsetBot - menuExtras;
                        if (that.options.container) {
                            if (!$menu.data("height")) $menu.data("height", $menu.height());
                            getHeight = $menu.data("height");
                        } else {
                            getHeight = $menu.height();
                        }
                        if (that.options.dropupAuto) {
                            that.$newElement.toggleClass("dropup", selectOffsetTop > selectOffsetBot && menuHeight - menuExtras < getHeight);
                        }
                        if (that.$newElement.hasClass("dropup")) {
                            menuHeight = selectOffsetTop - menuExtras;
                        }
                        if (lisVisible.length + optGroup.length > 3) {
                            minHeight = liHeight * 3 + menuExtras - 2;
                        } else {
                            minHeight = 0;
                        }
                        $menu.css({
                            "max-height": menuHeight + "px",
                            overflow: "hidden",
                            "min-height": minHeight + headerHeight + searchHeight + actionsHeight + doneButtonHeight + "px"
                        });
                        $menuInner.css({
                            "max-height": menuHeight - headerHeight - searchHeight - actionsHeight - doneButtonHeight - menuPadding + "px",
                            "overflow-y": "auto",
                            "min-height": Math.max(minHeight - menuPadding, 0) + "px"
                        });
                    };
                    getSize();
                    this.$searchbox.off("input.getSize propertychange.getSize").on("input.getSize propertychange.getSize", getSize);
                    $window.off("resize.getSize scroll.getSize").on("resize.getSize scroll.getSize", getSize);
                } else if (this.options.size && this.options.size != "auto" && this.$lis.not(notDisabled).length > this.options.size) {
                    var optIndex = this.$lis.not(".divider").not(notDisabled).children().slice(0, this.options.size).last().parent().index(), divLength = this.$lis.slice(0, optIndex + 1).filter(".divider").length;
                    menuHeight = liHeight * this.options.size + divLength * divHeight + menuPadding;
                    if (that.options.container) {
                        if (!$menu.data("height")) $menu.data("height", $menu.height());
                        getHeight = $menu.data("height");
                    } else {
                        getHeight = $menu.height();
                    }
                    if (that.options.dropupAuto) {
                        //noinspection JSUnusedAssignment
                        this.$newElement.toggleClass("dropup", selectOffsetTop > selectOffsetBot && menuHeight - menuExtras < getHeight);
                    }
                    $menu.css({
                        "max-height": menuHeight + headerHeight + searchHeight + actionsHeight + doneButtonHeight + "px",
                        overflow: "hidden",
                        "min-height": ""
                    });
                    $menuInner.css({
                        "max-height": menuHeight - menuPadding + "px",
                        "overflow-y": "auto",
                        "min-height": ""
                    });
                }
            },
            setWidth: function() {
                if (this.options.width === "auto") {
                    this.$menu.css("min-width", "0");
                    // Get correct width if element is hidden
                    var $selectClone = this.$menu.parent().clone().appendTo("body"), $selectClone2 = this.options.container ? this.$newElement.clone().appendTo("body") : $selectClone, ulWidth = $selectClone.children(".dropdown-menu").outerWidth(), btnWidth = $selectClone2.css("width", "auto").children("button").outerWidth();
                    $selectClone.remove();
                    $selectClone2.remove();
                    // Set width to whatever's larger, button title or longest option
                    this.$newElement.css("width", Math.max(ulWidth, btnWidth) + "px");
                } else if (this.options.width === "fit") {
                    // Remove inline min-width so width can be changed from 'auto'
                    this.$menu.css("min-width", "");
                    this.$newElement.css("width", "").addClass("fit-width");
                } else if (this.options.width) {
                    // Remove inline min-width so width can be changed from 'auto'
                    this.$menu.css("min-width", "");
                    this.$newElement.css("width", this.options.width);
                } else {
                    // Remove inline min-width/width so width can be changed
                    this.$menu.css("min-width", "");
                    this.$newElement.css("width", "");
                }
                // Remove fit-width class if width is changed programmatically
                if (this.$newElement.hasClass("fit-width") && this.options.width !== "fit") {
                    this.$newElement.removeClass("fit-width");
                }
            },
            selectPosition: function() {
                this.$bsContainer = $('<div class="bs-container" />');
                var that = this, pos, actualHeight, getPlacement = function($element) {
                    that.$bsContainer.addClass($element.attr("class").replace(/form-control|fit-width/gi, "")).toggleClass("dropup", $element.hasClass("dropup"));
                    pos = $element.offset();
                    actualHeight = $element.hasClass("dropup") ? 0 : $element[0].offsetHeight;
                    that.$bsContainer.css({
                        top: pos.top + actualHeight,
                        left: pos.left,
                        width: $element[0].offsetWidth
                    });
                };
                this.$newElement.on("click", function() {
                    var $this = $(this);
                    if (that.isDisabled()) {
                        return;
                    }
                    getPlacement($this);
                    that.$bsContainer.appendTo(that.options.container).toggleClass("open", !$this.hasClass("open")).append(that.$menu);
                });
                $(window).on("resize scroll", function() {
                    getPlacement(that.$newElement);
                });
                this.$element.on("hide.bs.select", function() {
                    that.$menu.data("height", that.$menu.height());
                    that.$bsContainer.detach();
                });
            },
            setSelected: function(index, selected, $lis) {
                if (!$lis) {
                    $lis = this.findLis().eq(this.liObj[index]);
                }
                $lis.toggleClass("selected", selected);
            },
            setDisabled: function(index, disabled, $lis) {
                if (!$lis) {
                    $lis = this.findLis().eq(this.liObj[index]);
                }
                if (disabled) {
                    $lis.addClass("disabled").children("a").attr("href", "#").attr("tabindex", -1);
                } else {
                    $lis.removeClass("disabled").children("a").removeAttr("href").attr("tabindex", 0);
                }
            },
            isDisabled: function() {
                return this.$element[0].disabled;
            },
            checkDisabled: function() {
                var that = this;
                if (this.isDisabled()) {
                    this.$newElement.addClass("disabled");
                    this.$button.addClass("disabled").attr("tabindex", -1);
                } else {
                    if (this.$button.hasClass("disabled")) {
                        this.$newElement.removeClass("disabled");
                        this.$button.removeClass("disabled");
                    }
                    if (this.$button.attr("tabindex") == -1 && !this.$element.data("tabindex")) {
                        this.$button.removeAttr("tabindex");
                    }
                }
                this.$button.click(function() {
                    return !that.isDisabled();
                });
            },
            tabIndex: function() {
                if (this.$element.is("[tabindex]")) {
                    this.$element.data("tabindex", this.$element.attr("tabindex"));
                    this.$button.attr("tabindex", this.$element.data("tabindex"));
                }
            },
            clickListener: function() {
                var that = this, $document = $(document);
                this.$newElement.on("touchstart.dropdown", ".dropdown-menu", function(e) {
                    e.stopPropagation();
                });
                $document.data("spaceSelect", false);
                this.$button.on("keyup", function(e) {
                    if (/(32)/.test(e.keyCode.toString(10)) && $document.data("spaceSelect")) {
                        e.preventDefault();
                        $document.data("spaceSelect", false);
                    }
                });
                this.$newElement.on("click", function() {
                    that.setSize();
                    that.$element.on("shown.bs.select", function() {
                        if (!that.options.liveSearch && !that.multiple) {
                            that.$menuInner.find(".selected a").focus();
                        } else if (!that.multiple) {
                            var selectedIndex = that.liObj[that.$element[0].selectedIndex];
                            if (typeof selectedIndex !== "number" || that.options.size === false) return;
                            // scroll to selected option
                            var offset = that.$lis.eq(selectedIndex)[0].offsetTop - that.$menuInner[0].offsetTop;
                            offset = offset - that.$menuInner[0].offsetHeight / 2 + that.sizeInfo.liHeight / 2;
                            that.$menuInner[0].scrollTop = offset;
                        }
                    });
                });
                this.$menuInner.on("click", "li a", function(e) {
                    var $this = $(this), clickedIndex = $this.parent().data("originalIndex"), prevValue = that.$element.val(), prevIndex = that.$element.prop("selectedIndex");
                    // Don't close on multi choice menu
                    if (that.multiple) {
                        e.stopPropagation();
                    }
                    e.preventDefault();
                    //Don't run if we have been disabled
                    if (!that.isDisabled() && !$this.parent().hasClass("disabled")) {
                        var $options = that.$element.find("option"), $option = $options.eq(clickedIndex), state = $option.prop("selected"), $optgroup = $option.parent("optgroup"), maxOptions = that.options.maxOptions, maxOptionsGrp = $optgroup.data("maxOptions") || false;
                        if (!that.multiple) {
                            // Deselect all others if not multi select box
                            $options.prop("selected", false);
                            $option.prop("selected", true);
                            that.$menuInner.find(".selected").removeClass("selected");
                            that.setSelected(clickedIndex, true);
                        } else {
                            // Toggle the one we have chosen if we are multi select.
                            $option.prop("selected", !state);
                            that.setSelected(clickedIndex, !state);
                            $this.blur();
                            if (maxOptions !== false || maxOptionsGrp !== false) {
                                var maxReached = maxOptions < $options.filter(":selected").length, maxReachedGrp = maxOptionsGrp < $optgroup.find("option:selected").length;
                                if (maxOptions && maxReached || maxOptionsGrp && maxReachedGrp) {
                                    if (maxOptions && maxOptions == 1) {
                                        $options.prop("selected", false);
                                        $option.prop("selected", true);
                                        that.$menuInner.find(".selected").removeClass("selected");
                                        that.setSelected(clickedIndex, true);
                                    } else if (maxOptionsGrp && maxOptionsGrp == 1) {
                                        $optgroup.find("option:selected").prop("selected", false);
                                        $option.prop("selected", true);
                                        var optgroupID = $this.parent().data("optgroup");
                                        that.$menuInner.find('[data-optgroup="' + optgroupID + '"]').removeClass("selected");
                                        that.setSelected(clickedIndex, true);
                                    } else {
                                        var maxOptionsArr = typeof that.options.maxOptionsText === "function" ? that.options.maxOptionsText(maxOptions, maxOptionsGrp) : that.options.maxOptionsText, maxTxt = maxOptionsArr[0].replace("{n}", maxOptions), maxTxtGrp = maxOptionsArr[1].replace("{n}", maxOptionsGrp), $notify = $('<div class="notify"></div>');
                                        // If {var} is set in array, replace it
                                        /** @deprecated */
                                        if (maxOptionsArr[2]) {
                                            maxTxt = maxTxt.replace("{var}", maxOptionsArr[2][maxOptions > 1 ? 0 : 1]);
                                            maxTxtGrp = maxTxtGrp.replace("{var}", maxOptionsArr[2][maxOptionsGrp > 1 ? 0 : 1]);
                                        }
                                        $option.prop("selected", false);
                                        that.$menu.append($notify);
                                        if (maxOptions && maxReached) {
                                            $notify.append($("<div>" + maxTxt + "</div>"));
                                            that.$element.trigger("maxReached.bs.select");
                                        }
                                        if (maxOptionsGrp && maxReachedGrp) {
                                            $notify.append($("<div>" + maxTxtGrp + "</div>"));
                                            that.$element.trigger("maxReachedGrp.bs.select");
                                        }
                                        setTimeout(function() {
                                            that.setSelected(clickedIndex, false);
                                        }, 10);
                                        $notify.delay(750).fadeOut(300, function() {
                                            $(this).remove();
                                        });
                                    }
                                }
                            }
                        }
                        if (!that.multiple) {
                            that.$button.focus();
                        } else if (that.options.liveSearch) {
                            that.$searchbox.focus();
                        }
                        // Trigger select 'change'
                        if (prevValue != that.$element.val() && that.multiple || prevIndex != that.$element.prop("selectedIndex") && !that.multiple) {
                            that.$element.triggerNative("change");
                            // $option.prop('selected') is current option state (selected/unselected). state is previous option state.
                            that.$element.trigger("changed.bs.select", [ clickedIndex, $option.prop("selected"), state ]);
                        }
                    }
                });
                this.$menu.on("click", "li.disabled a, .popover-title, .popover-title :not(.close)", function(e) {
                    if (e.currentTarget == this) {
                        e.preventDefault();
                        e.stopPropagation();
                        if (that.options.liveSearch && !$(e.target).hasClass("close")) {
                            that.$searchbox.focus();
                        } else {
                            that.$button.focus();
                        }
                    }
                });
                this.$menuInner.on("click", ".divider, .dropdown-header", function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    if (that.options.liveSearch) {
                        that.$searchbox.focus();
                    } else {
                        that.$button.focus();
                    }
                });
                this.$menu.on("click", ".popover-title .close", function() {
                    that.$button.click();
                });
                this.$searchbox.on("click", function(e) {
                    e.stopPropagation();
                });
                this.$menu.on("click", ".actions-btn", function(e) {
                    if (that.options.liveSearch) {
                        that.$searchbox.focus();
                    } else {
                        that.$button.focus();
                    }
                    e.preventDefault();
                    e.stopPropagation();
                    if ($(this).hasClass("bs-select-all")) {
                        that.selectAll();
                    } else {
                        that.deselectAll();
                    }
                    that.$element.triggerNative("change");
                });
                this.$element.change(function() {
                    that.render(false);
                });
            },
            liveSearchListener: function() {
                var that = this, $no_results = $('<li class="no-results"></li>');
                this.$newElement.on("click.dropdown.data-api touchstart.dropdown.data-api", function() {
                    that.$menuInner.find(".active").removeClass("active");
                    if (!!that.$searchbox.val()) {
                        that.$searchbox.val("");
                        that.$lis.not(".is-hidden").removeClass("hidden");
                        if (!!$no_results.parent().length) $no_results.remove();
                    }
                    if (!that.multiple) that.$menuInner.find(".selected").addClass("active");
                    setTimeout(function() {
                        that.$searchbox.focus();
                    }, 10);
                });
                this.$searchbox.on("click.dropdown.data-api focus.dropdown.data-api touchend.dropdown.data-api", function(e) {
                    e.stopPropagation();
                });
                this.$searchbox.on("input propertychange", function() {
                    if (that.$searchbox.val()) {
                        var $searchBase = that.$lis.not(".is-hidden").removeClass("hidden").children("a");
                        if (that.options.liveSearchNormalize) {
                            $searchBase = $searchBase.not(":a" + that._searchStyle() + '("' + normalizeToBase(that.$searchbox.val()) + '")');
                        } else {
                            $searchBase = $searchBase.not(":" + that._searchStyle() + '("' + that.$searchbox.val() + '")');
                        }
                        $searchBase.parent().addClass("hidden");
                        that.$lis.filter(".dropdown-header").each(function() {
                            var $this = $(this), optgroup = $this.data("optgroup");
                            if (that.$lis.filter("[data-optgroup=" + optgroup + "]").not($this).not(".hidden").length === 0) {
                                $this.addClass("hidden");
                                that.$lis.filter("[data-optgroup=" + optgroup + "div]").addClass("hidden");
                            }
                        });
                        var $lisVisible = that.$lis.not(".hidden");
                        // hide divider if first or last visible, or if followed by another divider
                        $lisVisible.each(function(index) {
                            var $this = $(this);
                            if ($this.hasClass("divider") && ($this.index() === $lisVisible.first().index() || $this.index() === $lisVisible.last().index() || $lisVisible.eq(index + 1).hasClass("divider"))) {
                                $this.addClass("hidden");
                            }
                        });
                        if (!that.$lis.not(".hidden, .no-results").length) {
                            if (!!$no_results.parent().length) {
                                $no_results.remove();
                            }
                            $no_results.html(that.options.noneResultsText.replace("{0}", '"' + htmlEscape(that.$searchbox.val()) + '"')).show();
                            that.$menuInner.append($no_results);
                        } else if (!!$no_results.parent().length) {
                            $no_results.remove();
                        }
                    } else {
                        that.$lis.not(".is-hidden").removeClass("hidden");
                        if (!!$no_results.parent().length) {
                            $no_results.remove();
                        }
                    }
                    that.$lis.filter(".active").removeClass("active");
                    if (that.$searchbox.val()) that.$lis.not(".hidden, .divider, .dropdown-header").eq(0).addClass("active").children("a").focus();
                    $(this).focus();
                });
            },
            _searchStyle: function() {
                var styles = {
                    begins: "ibegins",
                    startsWith: "ibegins"
                };
                return styles[this.options.liveSearchStyle] || "icontains";
            },
            val: function(value) {
                if (typeof value !== "undefined") {
                    this.$element.val(value);
                    this.render();
                    return this.$element;
                } else {
                    return this.$element.val();
                }
            },
            changeAll: function(status) {
                if (typeof status === "undefined") status = true;
                this.findLis();
                var $options = this.$element.find("option"), $lisVisible = this.$lis.not(".divider, .dropdown-header, .disabled, .hidden").toggleClass("selected", status), lisVisLen = $lisVisible.length, selectedOptions = [];
                for (var i = 0; i < lisVisLen; i++) {
                    var origIndex = $lisVisible[i].getAttribute("data-original-index");
                    selectedOptions[selectedOptions.length] = $options.eq(origIndex)[0];
                }
                $(selectedOptions).prop("selected", status);
                this.render(false);
            },
            selectAll: function() {
                return this.changeAll(true);
            },
            deselectAll: function() {
                return this.changeAll(false);
            },
            keydown: function(e) {
                var $this = $(this), $parent = $this.is("input") ? $this.parent().parent() : $this.parent(), $items, that = $parent.data("this"), index, next, first, last, prev, nextPrev, prevIndex, isActive, selector = ":not(.disabled, .hidden, .dropdown-header, .divider)", keyCodeMap = {
                    32: " ",
                    48: "0",
                    49: "1",
                    50: "2",
                    51: "3",
                    52: "4",
                    53: "5",
                    54: "6",
                    55: "7",
                    56: "8",
                    57: "9",
                    59: ";",
                    65: "a",
                    66: "b",
                    67: "c",
                    68: "d",
                    69: "e",
                    70: "f",
                    71: "g",
                    72: "h",
                    73: "i",
                    74: "j",
                    75: "k",
                    76: "l",
                    77: "m",
                    78: "n",
                    79: "o",
                    80: "p",
                    81: "q",
                    82: "r",
                    83: "s",
                    84: "t",
                    85: "u",
                    86: "v",
                    87: "w",
                    88: "x",
                    89: "y",
                    90: "z",
                    96: "0",
                    97: "1",
                    98: "2",
                    99: "3",
                    100: "4",
                    101: "5",
                    102: "6",
                    103: "7",
                    104: "8",
                    105: "9"
                };
                if (that.options.liveSearch) $parent = $this.parent().parent();
                if (that.options.container) $parent = that.$menu;
                $items = $("[role=menu] li", $parent);
                isActive = that.$menu.parent().hasClass("open");
                if (!isActive && (e.keyCode >= 48 && e.keyCode <= 57 || e.keyCode >= 96 && e.keyCode <= 105 || e.keyCode >= 65 && e.keyCode <= 90)) {
                    if (!that.options.container) {
                        that.setSize();
                        that.$menu.parent().addClass("open");
                        isActive = true;
                    } else {
                        that.$newElement.trigger("click");
                    }
                    that.$searchbox.focus();
                }
                if (that.options.liveSearch) {
                    if (/(^9$|27)/.test(e.keyCode.toString(10)) && isActive && that.$menu.find(".active").length === 0) {
                        e.preventDefault();
                        that.$menu.parent().removeClass("open");
                        if (that.options.container) that.$newElement.removeClass("open");
                        that.$button.focus();
                    }
                    // $items contains li elements when liveSearch is enabled
                    $items = $("[role=menu] li" + selector, $parent);
                    if (!$this.val() && !/(38|40)/.test(e.keyCode.toString(10))) {
                        if ($items.filter(".active").length === 0) {
                            $items = that.$menuInner.find("li");
                            if (that.options.liveSearchNormalize) {
                                $items = $items.filter(":a" + that._searchStyle() + "(" + normalizeToBase(keyCodeMap[e.keyCode]) + ")");
                            } else {
                                $items = $items.filter(":" + that._searchStyle() + "(" + keyCodeMap[e.keyCode] + ")");
                            }
                        }
                    }
                }
                if (!$items.length) return;
                if (/(38|40)/.test(e.keyCode.toString(10))) {
                    index = $items.index($items.find("a").filter(":focus").parent());
                    first = $items.filter(selector).first().index();
                    last = $items.filter(selector).last().index();
                    next = $items.eq(index).nextAll(selector).eq(0).index();
                    prev = $items.eq(index).prevAll(selector).eq(0).index();
                    nextPrev = $items.eq(next).prevAll(selector).eq(0).index();
                    if (that.options.liveSearch) {
                        $items.each(function(i) {
                            if (!$(this).hasClass("disabled")) {
                                $(this).data("index", i);
                            }
                        });
                        index = $items.index($items.filter(".active"));
                        first = $items.first().data("index");
                        last = $items.last().data("index");
                        next = $items.eq(index).nextAll().eq(0).data("index");
                        prev = $items.eq(index).prevAll().eq(0).data("index");
                        nextPrev = $items.eq(next).prevAll().eq(0).data("index");
                    }
                    prevIndex = $this.data("prevIndex");
                    if (e.keyCode == 38) {
                        if (that.options.liveSearch) index--;
                        if (index != nextPrev && index > prev) index = prev;
                        if (index < first) index = first;
                        if (index == prevIndex) index = last;
                    } else if (e.keyCode == 40) {
                        if (that.options.liveSearch) index++;
                        if (index == -1) index = 0;
                        if (index != nextPrev && index < next) index = next;
                        if (index > last) index = last;
                        if (index == prevIndex) index = first;
                    }
                    $this.data("prevIndex", index);
                    if (!that.options.liveSearch) {
                        $items.eq(index).children("a").focus();
                    } else {
                        e.preventDefault();
                        if (!$this.hasClass("dropdown-toggle")) {
                            $items.removeClass("active").eq(index).addClass("active").children("a").focus();
                            $this.focus();
                        }
                    }
                } else if (!$this.is("input")) {
                    var keyIndex = [], count, prevKey;
                    $items.each(function() {
                        if (!$(this).hasClass("disabled")) {
                            if ($.trim($(this).children("a").text().toLowerCase()).substring(0, 1) == keyCodeMap[e.keyCode]) {
                                keyIndex.push($(this).index());
                            }
                        }
                    });
                    count = $(document).data("keycount");
                    count++;
                    $(document).data("keycount", count);
                    prevKey = $.trim($(":focus").text().toLowerCase()).substring(0, 1);
                    if (prevKey != keyCodeMap[e.keyCode]) {
                        count = 1;
                        $(document).data("keycount", count);
                    } else if (count >= keyIndex.length) {
                        $(document).data("keycount", 0);
                        if (count > keyIndex.length) count = 1;
                    }
                    $items.eq(keyIndex[count - 1]).children("a").focus();
                }
                // Select focused option if "Enter", "Spacebar" or "Tab" (when selectOnTab is true) are pressed inside the menu.
                if ((/(13|32)/.test(e.keyCode.toString(10)) || /(^9$)/.test(e.keyCode.toString(10)) && that.options.selectOnTab) && isActive) {
                    if (!/(32)/.test(e.keyCode.toString(10))) e.preventDefault();
                    if (!that.options.liveSearch) {
                        var elem = $(":focus");
                        elem.click();
                        // Bring back focus for multiselects
                        elem.focus();
                        // Prevent screen from scrolling if the user hit the spacebar
                        e.preventDefault();
                        // Fixes spacebar selection of dropdown items in FF & IE
                        $(document).data("spaceSelect", true);
                    } else if (!/(32)/.test(e.keyCode.toString(10))) {
                        that.$menuInner.find(".active a").click();
                        $this.focus();
                    }
                    $(document).data("keycount", 0);
                }
                if (/(^9$|27)/.test(e.keyCode.toString(10)) && isActive && (that.multiple || that.options.liveSearch) || /(27)/.test(e.keyCode.toString(10)) && !isActive) {
                    that.$menu.parent().removeClass("open");
                    if (that.options.container) that.$newElement.removeClass("open");
                    that.$button.focus();
                }
            },
            mobile: function() {
                this.$element.addClass("mobile-device").appendTo(this.$newElement);
                if (this.options.container) this.$menu.hide();
            },
            refresh: function() {
                this.$lis = null;
                this.liObj = {};
                this.reloadLi();
                this.render();
                this.checkDisabled();
                this.liHeight(true);
                this.setStyle();
                this.setWidth();
                if (this.$lis) this.$searchbox.trigger("propertychange");
                this.$element.trigger("refreshed.bs.select");
            },
            hide: function() {
                this.$newElement.hide();
            },
            show: function() {
                this.$newElement.show();
            },
            remove: function() {
                this.$newElement.remove();
                this.$element.remove();
            },
            destroy: function() {
                this.$newElement.remove();
                if (this.$bsContainer) {
                    this.$bsContainer.remove();
                } else {
                    this.$menu.remove();
                }
                this.$element.off(".bs.select").removeData("selectpicker").removeClass("bs-select-hidden selectpicker");
            }
        };
        // SELECTPICKER PLUGIN DEFINITION
        // ==============================
        function Plugin(option, event) {
            // get the args of the outer function..
            var args = arguments;
            // The arguments of the function are explicitly re-defined from the argument list, because the shift causes them
            // to get lost/corrupted in android 2.3 and IE9 #715 #775
            var _option = option, _event = event;
            [].shift.apply(args);
            var value;
            var chain = this.each(function() {
                var $this = $(this);
                if ($this.is("select")) {
                    var data = $this.data("selectpicker"), options = typeof _option == "object" && _option;
                    if (!data) {
                        var config = $.extend({}, Selectpicker.DEFAULTS, $.fn.selectpicker.defaults || {}, $this.data(), options);
                        config.template = $.extend({}, Selectpicker.DEFAULTS.template, $.fn.selectpicker.defaults ? $.fn.selectpicker.defaults.template : {}, $this.data().template, options.template);
                        $this.data("selectpicker", data = new Selectpicker(this, config, _event));
                    } else if (options) {
                        for (var i in options) {
                            if (options.hasOwnProperty(i)) {
                                data.options[i] = options[i];
                            }
                        }
                    }
                    if (typeof _option == "string") {
                        if (data[_option] instanceof Function) {
                            value = data[_option].apply(data, args);
                        } else {
                            value = data.options[_option];
                        }
                    }
                }
            });
            if (typeof value !== "undefined") {
                //noinspection JSUnusedAssignment
                return value;
            } else {
                return chain;
            }
        }
        var old = $.fn.selectpicker;
        $.fn.selectpicker = Plugin;
        $.fn.selectpicker.Constructor = Selectpicker;
        // SELECTPICKER NO CONFLICT
        // ========================
        $.fn.selectpicker.noConflict = function() {
            $.fn.selectpicker = old;
            return this;
        };
        $(document).data("keycount", 0).on("keydown.bs.select", '.bootstrap-select [data-toggle=dropdown], .bootstrap-select [role="menu"], .bs-searchbox input', Selectpicker.prototype.keydown).on("focusin.modal", '.bootstrap-select [data-toggle=dropdown], .bootstrap-select [role="menu"], .bs-searchbox input', function(e) {
            e.stopPropagation();
        });
        // SELECTPICKER DATA-API
        // =====================
        $(window).on("load.bs.select.data-api", function() {
            $(".selectpicker").each(function() {
                var $selectpicker = $(this);
                Plugin.call($selectpicker, $selectpicker.data());
            });
        });
    })(jQuery);
});

/*!
 * jQuery Textarea AutoGrow plugin
 * Author: Bruno Sampaio
 * Licensed under the MIT license
 */
(function($) {
    var pluginName = "autogrow";
    var textareaClass = pluginName + "-field";
    var mirrorClass = pluginName + "-mirror";
    $.fn[pluginName] = function(options) {
        return this.each(function(index, element) {
            if (element.tagName != "TEXTAREA") return true;
            var textarea = $(element);
            var mirror = $("<div></div>");
            // Add mirror classes
            mirror.addClass(mirrorClass);
            // Add options properties to mirror element
            if (options !== undefined) {
                if (options.id !== undefined) mirror.attr("id", index == 0 ? options.id : options.id + "-" + index);
                if (options.classes !== undefined) mirror.addClass(options.classes);
            }
            textarea.addClass(textareaClass).on("input keyup", function(event) {
                var message = textarea.val();
                // Add a non breakable space to the message if it is empty or the last character is a line break (otherwise line break height is ignored)
                if (!message || message.charAt(message.length - 1) == "\n") message += " ";
                // Parse message content
                // Replace all line breaks in the message by the line break HTML element and add message to mirror element
                message = message.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/ /g, "&nbsp;").replace(/\n/g, "<br/>");
                // Add text to message field
                mirror.html(message);
                // Set textarea height equal to mirror height
                textarea.height(mirror.height());
            }).off(pluginName + ".resize").on(pluginName + ".resize", function() {
                mirror.css({
                    border: textarea.css("border"),
                    "font-family": textarea.css("font-family"),
                    "font-size": textarea.css("font-size"),
                    "font-weight": textarea.css("font-weight"),
                    "letter-spacing": textarea.css("letter-spacing"),
                    "line-height": textarea.css("line-height"),
                    padding: textarea.css("padding"),
                    position: "absolute",
                    visibility: "hidden",
                    "white-space": "normal",
                    width: textarea.css("width"),
                    "word-break": "break-word",
                    "z-index": -1,
                    zoom: textarea.css("zoom")
                });
            }).trigger(pluginName + ".resize").after(mirror);
        });
    };
})(jQuery);

/* ========================================================================
 * DOM-based Routing
 * Based on http://goo.gl/EUTi53 by Paul Irish
 *
 * Only fires on body classes that match. If a body class contains a dash,
 * replace the dash with an underscore when adding it to the object below.
 *
 * .noConflict()
 * The routing is enclosed within an anonymous function so that you can
 * always reference jQuery with $, even when in .noConflict() mode.
 *
 * Google CDN, Latest jQuery
 * To use the default WordPress version of jQuery, go to lib/config.php and
 * remove or comment out: add_theme_support('jquery-cdn');
 * ======================================================================== */
(function($) {
    // Use this variable to set up the common and page specific functions. If you
    // rename this variable, you will also need to rename the namespace below.
    var wefoster = {
        // All pages
        common: {
            init: function() {
                $(".bp-suggestions").autogrow();
                $('[data-toggle="tooltip"]').tooltip();
                //Hide Unstyled Flash
                $("#quick-menu-wrap").removeClass("js-flash");
                $("#dropdown-filter").removeClass("js-flash");
                $("#whats-new-js-wrap").removeClass("js-flash");
                $("#whats-new-options").removeClass("js-flash");
                //Hide header on down scroll
                $(".navbar-headroom").headroom({
                    tolerance: 5,
                    offset: 50
                });
                //See if a user has a filter enabled
                $("#activity-filter-by,#activity-filter-select").on("change", function() {
                    if (this.value === "-1" || this.value === 0) {
                        // Everything is selected
                        $("#activity-filter-notice").removeClass("visible").hide();
                    } else {
                        // Filter is on
                        $("#activity-filter-notice").addClass("visible");
                        var text = $("#activity-filter-by option[value='" + $(this).val() + "']").html();
                        $("#activity-filter-notice span").html(text);
                    }
                }).trigger("change");
                // Reset value on click
                $("#reset").click(function() {
                    $("#activity-filter-by").val("-1").trigger("change");
                });
                //Bootstrap tooltips
                jQuery(".wefoster-bootstrap-tooltips .navbar-nav > li > a, .wefoster-bootstrap-tooltips .navbar-brand").tooltip({
                    container: "body",
                    placement: "bottom",
                    delay: {
                        show: 300,
                        hide: 100
                    }
                });
                jQuery(".wefoster-bootstrap-tooltips.wefoster-sidebar-left #vertical-activity-tabs li a,.wefoster-bootstrap-tooltips .dropdown a").tooltip({
                    container: "body",
                    placement: "right",
                    delay: {
                        show: 300,
                        hide: 100
                    }
                });
                jQuery(".wefoster-bootstrap-tooltips.wefoster-sidebar-right #vertical-activity-tabs li a,.wefoster-bootstrap-tooltips .dropdown a").tooltip({
                    container: "body",
                    placement: "left",
                    delay: {
                        show: 300,
                        hide: 100
                    }
                });
                jQuery(".dir-search input[type='text']").focusin(function() {
                    jQuery(".dir-search input[type='submit']").show(400);
                }).focusout(function() {
                    jQuery(".dir-search input[type='submit']").hide(400);
                });
                // Add Button Bootstrap Styles
                jQuery(".widget_bps_widget submit,.bbp-submit-wrapper button,.join-group").addClass("btn btn-success");
                jQuery(".create-blog .main submit").addClass("btn btn-lg btn-success");
                //Add Bootstrap Class to Registration Form.
                jQuery(".buddypress.registration .register-section").addClass("col-sm-6");
                jQuery(".buddypress.registration .profile-details-section").addClass("col-sm-6");
                //Add inverse dropdown class if navbar-inverse is used
                jQuery(".navbar-inverse .dropdown-menu").addClass("inverse-dropdown");
                // Add Form Styling
                jQuery("textarea").addClass("form-control");
                jQuery(".text-input input[type=text]").addClass("form-control");
                jQuery(".dropdown-input select").addClass("selectpicker");
                jQuery("input[type=text],input[type=password],textarea#comment").addClass("form-control");
                jQuery("#whats-new-textarea #whats-new, #invite-anyone-by-email input[type=text]").addClass("form-control");
                //Add Table Styling
                jQuery("table").addClass("table table-striped");
                //Turn Selectbox into pretty dropdown
                jQuery("wefoster-bootstrap-select.directory.activity #activity-filter-select select,.wefoster-bootstrap-select .last select, #profile-quick-menu select").selectpicker({
                    style: "btn-hg btn-default",
                    menuStyle: "dropdown",
                    container: "body"
                });
                jQuery(".wefoster-bootstrap-select #whats-new-post-in,.wefoster-bootstrap-select .filter select,.field-visibility select, .wefoster-bootstrap-select .messages-options-nav select,.bbp-form select").selectpicker({
                    style: "btn-hg btn-default",
                    menuStyle: "dropdown",
                    container: "body"
                });
                if (/Android|webOS|iPhone|iPad|iPod|BlackBerry/i.test(navigator.userAgent)) {
                    $(".directory.activity #activity-filter-select select,#whats-new-post-in, .filter select").selectpicker("mobile");
                }
                //Activity Fade
                jQuery("#whats-new").focusin(function() {
                    jQuery("#aw-whats-new-submit").fadeIn();
                });
                //Responsive Embeds
                function setup_videos() {
                    // For embed YouTube videos
                    $('iframe:not(.embed-responsive-item)[src*="youtube.com"]').wrap('<div class="embed-responsive embed-responsive-16by9"></div>');
                    $('iframe:not(.embed-responsive-item)[src*="youtube.com"]').addClass("embed-responsive-item");
                    // For embed Vimeo videos
                    $('iframe:not(.embed-responsive-item)[src*="vimeo.com"]').wrap('<div class="embed-responsive embed-responsive-16by9"></div>');
                    $('iframe:not(.embed-responsive-item)[src*="vimeo.com"]').addClass("embed-responsive-item");
                    // For SlideShare slides
                    $('iframe:not(.embed-responsive-item)[src*="slideshare.net"]').wrap('<div class="embed-responsive embed-responsive-16by9"></div>');
                    $('iframe:not(.embed-responsive-item)[src*="slideshare.net"]').addClass("embed-responsive-item");
                }
                setup_videos();
                //Add them to BuddyPress Stream
                $(document).ajaxSuccess(function(response) {
                    //setup_videos();
                    setTimeout(setup_videos, 205);
                });
                //BuddyPress Cover Photo Dynamic Updating.
                if ("undefined" !== typeof window.bp) {
                    if (window.bp.Avatar) {
                        bp.Avatar.Attachment.on("change:url", function(data) {
                            console.log(data.attributes);
                        });
                    }
                    if (window.bp.CoverImage) {
                        bp.CoverImage.Attachment.on("change:url", function(data) {
                            console.log(data.attributes);
                        });
                    }
                }
            }
        },
        // Home page
        wefosterismobile: {
            init: function() {
                if ($("html").hasClass("touch")) {
                    FastClick.attach(document.body);
                }
                //Hide Unstyled Flash
                $("#mobile-primary-navigation").removeClass("js-flash");
                $("#buddypress-mobile-user-navigation").removeClass("js-flash");
                $("#buddypress-mobile-sidebar").removeClass("js-flash");
                //Our Navigation Menus
                $("#mobile-primary-navigation-menu-trigger").sidr({
                    name: "mobile-primary-navigation",
                    side: "right",
                    timing: "ease-in-out",
                    speed: 200
                });
                $("#close-mobile-primary-navigation").click(function() {
                    $.sidr("close", "mobile-primary-navigation");
                });
                //Our BuddyPress Mobile Sidebar
                $("#buddypress-mobile-user-navigation-trigger").sidr({
                    name: "buddypress-mobile-user-navigation",
                    timing: "ease-in-out",
                    speed: 200
                });
                $("#close-buddypress-mobile-user-navigation").click(function() {
                    $.sidr("close", "buddypress-mobile-user-navigation");
                });
                //Our BuddyPress Navigation
                $("#buddypress-mobile-sidebar-trigger").sidr({
                    name: "buddypress-mobile-sidebar",
                    timing: "ease-in-out",
                    speed: 200,
                    side: "right"
                });
                $("#close-buddypress-mobile-sidebar").click(function() {
                    $.sidr("close", "buddypress-mobile-sidebar");
                });
                //
                //Show & Hide our Sidr with clicks.
                ///
                $(".navigation-trigger, .close-panel-button, #buddypress-mobile-sidebar-trigger").on("click", function() {
                    $(this).toggleClass("closed");
                    $(".sidr").toggleClass("sidr-active");
                    $(".sidr").removeClass("sidr-no-transform");
                    $(".layout-wrapper").toggleClass("sidr-active-body");
                });
                //Hide Menus on Resize
                $(window).resize(function() {
                    $.sidr("close", "buddypress-mobile-user-navigation");
                    $.sidr("close", "mobile-primary-navigation");
                    $.sidr("close", "buddypress-mobile-sidebar");
                    $(".layout-wrapper").removeClass("sidr-active-body");
                    $(".sidr").addClass("sidr-no-transform");
                });
                //Smart Menu Tweaks
                $(".bp-sidebar-navigation").smartmenus({
                    subIndicatorsText: '<i class="fa fa-chevron-down"></i>'
                });
                //Add a styelized scrollbar on mobile
                $("#buddypress-mobile-sidebar,#buddypress-mobile-user-navigation,#mobile-primary-navigation").perfectScrollbar();
            }
        },
        // About us page, note the change from about-us to activity.
        activity: {
            init: function() {}
        }
    };
    // The routing fires all common scripts, followed by the page specific scripts.
    // Add additional events for more control over timing e.g. a finalize event
    var UTIL = {
        fire: function(func, funcname, args) {
            var namespace = wefoster;
            funcname = funcname === undefined ? "init" : funcname;
            if (func !== "" && namespace[func] && typeof namespace[func][funcname] === "function") {
                namespace[func][funcname](args);
            }
        },
        loadEvents: function() {
            UTIL.fire("common");
            $.each(document.body.className.replace(/-/g, "_").split(/\s+/), function(i, classnm) {
                UTIL.fire(classnm);
            });
        }
    };
    $(document).ready(UTIL.loadEvents);
})(jQuery);
//# sourceMappingURL=/wp-content/themes/wefoster/assets/js/scripts.min.js.map